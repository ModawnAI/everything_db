# 에뷰리띵 Node.js 백엔드 서버 상세 설계서

## 📱 개요
본 문서는 에뷰리띵 플러터 앱과 웹 관리자 시스템을 지원하는 Node.js 백엔드 서버의 모든 API 엔드포인트, 미들웨어, 비즈니스 로직에 대한 상세한 기능 정의와 Supabase 데이터베이스와의 상호작용을 설명합니다.

---

## 🏗️ 아키텍처 개요

### **기술 스택 및 프레임워크**
- **런타임**: Node.js 18+ LTS (최신 안정 버전)
- **프레임워크**: Express.js 4.18+ (RESTful API 구축)
- **언어**: TypeScript 5.0+ (타입 안전성 보장)
- **데이터베이스**: Supabase PostgreSQL (PostGIS 확장 포함)
- **인증**: Supabase Auth + JWT 토큰 검증
- **결제**: 토스페이먼츠 API 연동
- **푸시알림**: Firebase Cloud Messaging (FCM)
- **파일 스토리지**: Supabase Storage
- **로깅**: Winston + Morgan (구조화된 로그)
- **문서화**: Swagger/OpenAPI 3.0
- **환경관리**: dotenv + config 패턴

### **서버 구조 및 디렉토리**
```
src/
├── controllers/          # API 컨트롤러 (요청/응답 처리)
├── services/            # 비즈니스 로직 서비스
├── repositories/        # 데이터 접근 계층
├── middleware/          # 미들웨어 (인증, 검증, 로깅)
├── routes/             # API 라우트 정의
├── types/              # TypeScript 타입 정의
├── utils/              # 유틸리티 함수들
├── config/             # 설정 파일들
├── validators/         # 요청 데이터 검증
├── constants/          # 상수 정의
└── app.ts             # Express 앱 진입점
```

### **데이터 플로우 아키텍처**
```
Flutter App / Web Admin
         ↓
    Express Router
         ↓
   Authentication Middleware
         ↓
   Request Validation
         ↓
    Controller Layer
         ↓
    Service Layer (비즈니스 로직)
         ↓
   Repository Layer
         ↓
    Supabase Client
         ↓
   PostgreSQL Database
```

---

## 🔐 인증 및 보안 시스템

### **인증 미들웨어 구현**

#### **JWT 토큰 검증 미들웨어**
```typescript
// middleware/auth.middleware.ts
```

#### **기능 및 로직**
1. **토큰 추출 및 검증**
   - Authorization 헤더에서 Bearer 토큰 추출
   - Supabase JWT 시크릿으로 토큰 검증
   - 만료 시간 확인 및 페이로드 파싱

2. **사용자 정보 로드**
   - 토큰의 sub (사용자 ID)로 사용자 정보 조회
   - `user_status`가 'active'인지 확인
   - `req.user`에 사용자 정보 저장

3. **에러 처리**
   - 토큰 없음: 401 Unauthorized
   - 유효하지 않은 토큰: 401 Unauthorized  
   - 비활성 사용자: 403 Forbidden

#### **역할 기반 접근 제어 (RBAC)**
```typescript
// middleware/authorization.middleware.ts
```

#### **관리자 권한 검증**
1. **역할 확인**
   - `user_role` 필드 검증 ('admin', 'shop_owner', 'user')
   - 요청된 리소스에 대한 권한 매트릭스 확인

2. **샵 소유자 권한**
   - 샵 관련 API 접근 시 `owner_id` 일치 확인
   - 자신의 샵 데이터만 접근 가능하도록 제한

#### **Rate Limiting 및 보안**
```typescript
// middleware/rateLimiter.middleware.ts
```

1. **API 속도 제한**
   - 사용자별 분당 요청 수 제한 (기본: 100req/min)
   - 로그인 API는 더 엄격한 제한 (5req/min)
   - Redis 또는 메모리 기반 카운터 사용

2. **보안 헤더**
   - Helmet.js로 기본 보안 헤더 설정
   - CORS 정책 설정 (허용된 도메인만)
   - XSS, CSRF 보호 헤더 적용

---

## 📱 플러터 앱 API 엔드포인트

### **1. 사용자 인증 관련 API**

#### **1.1 POST /api/auth/social-login**

##### **요청 구조**
```json
{
  "provider": "kakao|apple|google",
  "token": "소셜_로그인_토큰",
  "deviceInfo": {
    "platform": "ios|android",
    "version": "앱_버전",
    "deviceId": "기기_고유_ID"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 신규 사용자 생성 또는 기존 사용자 업데이트
INSERT INTO public.users (
    id, email, name, social_provider, social_provider_id,
    referral_code, last_login_at
) VALUES (
    $user_id, $email, $name, $provider, $provider_id,
    generate_referral_code(), NOW()
) ON CONFLICT (id) DO UPDATE SET
    last_login_at = NOW();

-- FCM 토큰 등록/업데이트
INSERT INTO public.push_tokens (user_id, token, platform)
VALUES ($user_id, $fcm_token, $platform)
ON CONFLICT (user_id, token) DO UPDATE SET
    last_used_at = NOW();
```

##### **비즈니스 로직**
1. **소셜 토큰 검증**
   - 각 제공자별 토큰 검증 API 호출
   - 사용자 기본 정보 추출 (이메일, 이름)

2. **Supabase Auth 연동**
   - 소셜 로그인 정보로 Supabase 사용자 생성/로그인
   - JWT 토큰 발급 및 반환

3. **기기 정보 저장**
   - FCM 토큰 등록 (푸시 알림용)
   - 기기별 로그인 이력 추적

#### **1.2 POST /api/auth/register**

##### **요청 구조**
```json
{
  "name": "사용자_실명",
  "gender": "male|female|other|prefer_not_to_say",
  "birthDate": "1990-01-01",
  "phoneNumber": "010-1234-5678",
  "phoneVerified": true,
  "referralCode": "ABCD1234",
  "termsAccepted": true,
  "privacyAccepted": true,
  "marketingConsent": false
}
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 정보 업데이트
UPDATE public.users SET
    name = $name,
    gender = $gender::user_gender,
    birth_date = $birth_date,
    phone_number = $phone_number,
    phone_verified = $phone_verified,
    referred_by_code = $referral_code,
    terms_accepted_at = NOW(),
    privacy_accepted_at = NOW(),
    marketing_consent = $marketing_consent
WHERE id = auth.uid();

-- 추천인 통계 업데이트
UPDATE public.users SET 
    total_referrals = total_referrals + 1
WHERE referral_code = $referred_by_code;
```

##### **비즈니스 로직**
1. **입력 데이터 검증**
   - Joi 스키마로 모든 필드 검증
   - 전화번호 형식 검증 (한국 형식)
   - 생년월일 유효성 검사

2. **추천인 코드 처리**
   - 입력된 추천인 코드 존재 여부 확인
   - 추천인의 `total_referrals` 카운트 증가
   - 추천 관계 기록 저장

### **2. 홈 화면 관련 API**

#### **2.1 GET /api/shops/nearby**

##### **쿼리 파라미터**
```
?latitude=37.5665&longitude=126.9780&radius=10000&limit=30&offset=0&category=nail&partnered=true
```

##### **데이터베이스 상호작용**
```sql
-- 위치 기반 샵 조회 (PRD 2.1 알고리즘 적용)
SELECT s.*, 
       ST_Distance(s.location, ST_Point($longitude, $latitude)::geography) as distance,
       COUNT(r.id) as total_bookings,
       AVG(rv.rating) as average_rating,
       si.image_url as main_image
FROM public.shops s
LEFT JOIN public.reservations r ON s.id = r.shop_id
LEFT JOIN public.reviews rv ON s.id = rv.shop_id AND rv.status = 'active'
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE s.shop_status = 'active'
  AND ST_DWithin(s.location, ST_Point($longitude, $latitude)::geography, $radius)
  AND ($category IS NULL OR s.main_category = $category::service_category)
  AND ($partnered IS NULL OR s.shop_type = CASE WHEN $partnered THEN 'partnered' ELSE 'non_partnered' END)
GROUP BY s.id, si.image_url
ORDER BY 
  CASE WHEN s.shop_type = 'partnered' THEN 0 ELSE 1 END,
  s.partnership_started_at DESC,
  distance ASC
LIMIT $limit OFFSET $offset;
```

##### **비즈니스 로직**
1. **위치 기반 필터링**
   - PostGIS `ST_DWithin` 함수로 지정 반경 내 샵 조회
   - GPS 좌표를 GEOGRAPHY 타입으로 변환

2. **우선 순위 알고리즘**
   - 입점샵 (`shop_type = 'partnered'`) 최우선 노출
   - 입점샵 내에서는 최신 입점순 정렬
   - 비입점샵은 거리순 정렬

3. **성능 최적화**
   - 공간 인덱스 활용으로 빠른 위치 검색
   - 페이징으로 초기 로딩 시간 단축

#### **2.2 GET /api/user/favorites**

##### **데이터베이스 상호작용**
```sql
-- 사용자 즐겨찾기 샵 조회
SELECT s.*, uf.created_at as favorited_at,
       si.image_url as main_image
FROM public.user_favorites uf
JOIN public.shops s ON uf.shop_id = s.id
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE uf.user_id = $user_id AND s.shop_status = 'active'
ORDER BY uf.created_at DESC;
```

##### **비즈니스 로직**
- JWT 토큰에서 사용자 ID 추출
- 즐겨찾기한 순서대로 정렬
- 비활성화된 샵은 제외

### **3. 샵 상세 정보 API**

#### **3.1 GET /api/shops/:shopId**

##### **데이터베이스 상호작용**
```sql
-- 샵 상세 정보 조회
SELECT s.*,
       array_agg(DISTINCT si.image_url ORDER BY si.display_order) as shop_images,
       COUNT(DISTINCT r.id) as total_reviews,
       AVG(rv.rating) as average_rating,
       COUNT(DISTINCT res.id) as total_bookings
FROM public.shops s
LEFT JOIN public.shop_images si ON s.id = si.shop_id
LEFT JOIN public.reviews r ON s.id = r.shop_id AND r.status = 'active'
LEFT JOIN public.reservations res ON s.id = res.shop_id
WHERE s.id = $shop_id AND s.shop_status = 'active'
GROUP BY s.id;

-- 샵 서비스 목록
SELECT ss.*, 
       array_agg(ssi.image_url ORDER BY ssi.display_order) as service_images
FROM public.shop_services ss
LEFT JOIN public.service_images ssi ON ss.id = ssi.service_id
WHERE ss.shop_id = $shop_id AND ss.is_available = true
GROUP BY ss.id
ORDER BY ss.display_order, ss.category;
```

##### **비즈니스 로직**
1. **종합 정보 제공**
   - 샵 기본 정보 + 이미지 + 통계 데이터 통합
   - 서비스별 이미지와 가격 정보 포함

2. **영업시간 계산**
   - `operating_hours` JSONB 파싱
   - 현재 시간 기준 영업 상태 계산

#### **3.2 POST /api/shops/:shopId/favorite**

##### **데이터베이스 상호작용**
```sql
-- 즐겨찾기 추가/제거 토글
INSERT INTO public.user_favorites (user_id, shop_id)
VALUES ($user_id, $shop_id)
ON CONFLICT (user_id, shop_id) DO NOTHING;

-- 즐겨찾기 제거 (이미 존재하는 경우)
DELETE FROM public.user_favorites 
WHERE user_id = $user_id AND shop_id = $shop_id;
```

##### **비즈니스 로직**
- 현재 즐겨찾기 상태 확인 후 토글
- 동시성 제어를 위한 트랜잭션 처리

### **4. 예약 시스템 API**

#### **4.1 GET /api/shops/:shopId/available-slots**

##### **쿼리 파라미터**
```
?date=2024-03-15&serviceIds[]=uuid1&serviceIds[]=uuid2
```

##### **데이터베이스 상호작용**
```sql
-- 예약 가능한 시간 슬롯 조회
WITH time_slots AS (
    SELECT generate_series(
        $date::date + interval '9 hours',
        $date::date + interval '18 hours',
        interval '30 minutes'
    ) as slot_time
),
booked_slots AS (
    SELECT reservation_datetime
    FROM public.reservations
    WHERE shop_id = $shop_id 
      AND reservation_date = $date
      AND status IN ('confirmed', 'requested')
),
service_duration AS (
    SELECT MAX(duration_minutes) as max_duration
    FROM public.shop_services
    WHERE id = ANY($service_ids)
)
SELECT ts.slot_time
FROM time_slots ts
CROSS JOIN service_duration sd
WHERE NOT EXISTS (
    SELECT 1 FROM booked_slots bs
    WHERE bs.reservation_datetime BETWEEN 
        ts.slot_time AND ts.slot_time + (sd.max_duration || ' minutes')::interval
);
```

##### **비즈니스 로직**
1. **시간 슬롯 생성**
   - 영업시간 기반 30분 간격 슬롯 생성
   - 선택된 서비스 소요시간 고려

2. **예약 충돌 방지**
   - 기존 예약과 겹치는 시간 제외
   - 서비스 소요시간만큼 버퍼 적용

#### **4.2 POST /api/reservations**

##### **요청 구조**
```json
{
  "shopId": "uuid",
  "services": [
    {
      "serviceId": "uuid",
      "quantity": 1
    }
  ],
  "reservationDate": "2024-03-15",
  "reservationTime": "14:00",
  "specialRequests": "특별 요청사항",
  "pointsToUse": 5000
}
```

##### **데이터베이스 상호작용**
```sql
-- 예약 생성 트랜잭션
BEGIN;

-- 예약 메인 정보 생성
INSERT INTO public.reservations (
    user_id, shop_id, reservation_date, reservation_time,
    total_amount, deposit_amount, points_used, special_requests,
    status
) VALUES (
    $user_id, $shop_id, $date, $time,
    $total_amount, $deposit_amount, $points_used, $requests,
    'requested'
) RETURNING id;

-- 예약 서비스 연결
INSERT INTO public.reservation_services (
    reservation_id, service_id, quantity, unit_price, total_price
) VALUES ($reservation_id, $service_id, $quantity, $unit_price, $total_price);

-- 포인트 사용 처리
INSERT INTO public.point_transactions (
    user_id, reservation_id, transaction_type, amount, status
) VALUES (
    $user_id, $reservation_id, 'used_service', -$points_used, 'available'
);

COMMIT;
```

##### **비즈니스 로직**
1. **가격 계산**
   - 선택된 서비스들의 총액 계산
   - 포인트 할인 적용 (사용 가능 포인트 확인)
   - 예약금 비율 계산 (보통 20-30%)

2. **재고 및 시간 확인**
   - 요청된 시간 슬롯 재확인
   - 동시 예약 방지를 위한 락 처리

3. **알림 발송**
   - 사용자에게 예약 요청 완료 알림
   - 샵 사장에게 새 예약 요청 알림

### **5. 결제 시스템 API**

#### **5.1 POST /api/payments/toss/prepare**

##### **요청 구조**
```json
{
  "reservationId": "uuid",
  "paymentMethod": "toss_payments",
  "amount": 50000,
  "isDeposit": true
}
```

##### **토스페이먼츠 연동**
```typescript
// 토스페이먼츠 결제 준비
const tossResponse = await fetch('https://api.tosspayments.com/v1/payments', {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    amount: amount,
    orderId: `order_${reservationId}_${Date.now()}`,
    orderName: `에뷰리띵 예약금 결제`,
    customerName: user.name,
    customerEmail: user.email
  })
});
```

##### **데이터베이스 상호작용**
```sql
-- 결제 정보 생성
INSERT INTO public.payments (
    reservation_id, user_id, payment_method, amount,
    payment_provider, provider_order_id, is_deposit,
    payment_status
) VALUES (
    $reservation_id, $user_id, $payment_method, $amount,
    'toss_payments', $order_id, $is_deposit,
    'pending'
) RETURNING id;
```

#### **5.2 POST /api/payments/toss/confirm**

##### **토스페이먼츠 결제 승인**
```typescript
const confirmResponse = await fetch(`https://api.tosspayments.com/v1/payments/confirm`, {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    paymentKey: paymentKey,
    orderId: orderId,
    amount: amount
  })
});
```

##### **결제 완료 후 처리**
```sql
-- 결제 상태 업데이트
UPDATE public.payments SET
    payment_status = 'deposit_paid',
    provider_transaction_id = $transaction_id,
    paid_at = NOW()
WHERE provider_order_id = $order_id;

-- 예약 상태 업데이트  
UPDATE public.reservations SET
    status = 'confirmed'
WHERE id = $reservation_id;

-- 서비스 포인트 적립 (예약 완료 시)
SELECT award_service_points($reservation_id);
```

### **6. 포인트 시스템 API**

#### **6.1 GET /api/user/points**

##### **응답 구조**
```json
{
  "totalPoints": 15000,
  "availablePoints": 12000,
  "pendingPoints": 3000,
  "pointsThisMonth": 5000,
  "transactions": [...]
}
```

##### **데이터베이스 상호작용**
```sql
-- 포인트 요약 정보 조회
SELECT u.total_points, u.available_points,
       COALESCE(pending.pending_points, 0) as pending_points,
       COALESCE(this_month.points_this_month, 0) as points_this_month
FROM public.users u
LEFT JOIN (
    SELECT user_id, SUM(amount) as pending_points
    FROM public.point_transactions 
    WHERE status = 'pending' AND amount > 0
    GROUP BY user_id
) pending ON u.id = pending.user_id
LEFT JOIN (
    SELECT user_id, SUM(amount) as points_this_month
    FROM public.point_transactions 
    WHERE status = 'available' AND amount > 0
      AND created_at >= date_trunc('month', NOW())
    GROUP BY user_id
) this_month ON u.id = this_month.user_id
WHERE u.id = $user_id;
```

#### **6.2 POST /api/points/use**

##### **요청 구조**
```json
{
  "amount": 5000,
  "reservationId": "uuid",
  "description": "서비스 결제 사용"
}
```

##### **비즈니스 로직**
1. **사용 가능 포인트 확인**
   - 7일 제한 규칙 적용
   - 만료되지 않은 포인트만 사용

2. **포인트 차감 처리**
   - 선입선출(FIFO) 방식으로 차감
   - 트랜잭션으로 원자성 보장

#### **6.3 POST /api/admin/points/adjust**

##### **요청 구조**
```json
{
  "userId": "uuid",
  "amount": 5000,
  "reason": "고객 문의로 인한 포인트 보상",
  "type": "add" // "add" 또는 "subtract"
}
```

##### **응답 구조**
```json
{
  "success": true,
  "message": "포인트가 성공적으로 조정되었습니다",
  "adjustment": {
    "id": "uuid",
    "userId": "uuid",
    "amount": 5000,
    "type": "add",
    "reason": "고객 문의로 인한 포인트 보상",
    "previousBalance": 15000,
    "newBalance": 20000,
    "adjustedBy": "admin_uuid",
    "created_at": "2024-03-15T16:30:00Z"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 포인트 조정 트랜잭션
BEGIN;

-- 포인트 거래 내역 생성
INSERT INTO public.point_transactions (
    user_id, transaction_type, amount, description, 
    status, metadata
) VALUES (
    $user_id, 'adjusted', $amount, $description,
    'available', jsonb_build_object('adjusted_by', $admin_id)
);

-- 관리자 액션 로그 기록
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id,
    reason, metadata
) VALUES (
    $admin_id, 'points_adjusted', 'user', $user_id,
    $reason, jsonb_build_object('amount', $amount)
);

COMMIT;
```

#### **6.4 POST /api/admin/payments/partial-refund**

##### **요청 구조**
```json
{
  "paymentId": "uuid",
  "refundAmount": 25000,
  "reason": "고객 요청으로 인한 부분 환불",
  "refundMethod": "original" // "original" 또는 "points"
}
```

##### **응답 구조**
```json
{
  "success": true,
  "message": "부분 환불이 처리되었습니다",
  "refund": {
    "id": "uuid",
    "paymentId": "uuid",
    "refundAmount": 25000,
    "reason": "고객 요청으로 인한 부분 환불",
    "refundMethod": "original",
    "status": "partially_refunded",
    "processedAt": "2024-03-15T16:30:00Z"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 부분 환불 처리
UPDATE public.payments 
SET payment_status = CASE 
    WHEN $refund_amount = amount THEN 'refunded'
    ELSE 'partially_refunded'
  END,
    refund_amount = $refund_amount,
    refunded_at = NOW(),
    metadata = jsonb_set(
      metadata, 
      '{refund_reason}', 
      to_jsonb($reason)
    )
WHERE id = $payment_id;

-- 관리자 액션 로그 기록
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id,
    reason, metadata
) VALUES (
    $admin_id, 'refund_processed', 'payment', $payment_id,
    $reason, jsonb_build_object('refund_amount', $refund_amount)
);
```

---

## 🖥️ 웹 관리자 API 엔드포인트

### **1. 관리자 인증 API**

#### **1.1 POST /api/admin/login**

##### **요청 구조**
```json
{
  "email": "admin@ebeautything.com",
  "password": "secure_password"
}
```

##### **데이터베이스 상호작용**
```sql
-- 관리자 계정 확인
SELECT id, email, name, user_role 
FROM public.users 
WHERE email = $email 
  AND user_role IN ('admin', 'shop_owner')
  AND user_status = 'active';
```

##### **비즈니스 로직**
1. **이메일/비밀번호 검증**
   - Supabase Auth로 인증 처리
   - 관리자 역할 확인

2. **세션 관리**
   - JWT 토큰 발급 (longer expiry for admin)
   - 로그인 이력 기록
   - 다중 디바이스 로그인 정책 (최대 3개 디바이스)
   - 자동 토큰 갱신 (30분 간격)

3. **보안 강화**
   - 로그인 시도 제한 (5회 실패 시 30분 잠금)
   - IP 기반 접근 제한 (관리자 전용 IP 설정 가능)
   - 세션 타임아웃 (1시간 비활성 시 자동 로그아웃)

### **2. 사용자 관리 API (Super Admin)**

#### **2.1 GET /api/admin/users**

##### **쿼리 파라미터**
```
?page=1&limit=50&search=홍길동&status=active&role=user&sortBy=created_at&sortOrder=desc
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 목록 조회 (검색 및 필터 적용)
SELECT u.id, u.name, u.email, u.phone_number, u.user_status, 
       u.user_role, u.is_influencer, u.total_points, u.total_referrals,
       u.created_at, u.last_login_at,
       COUNT(r.id) as total_reservations
FROM public.users u
LEFT JOIN public.reservations r ON u.id = r.user_id
WHERE ($search IS NULL OR u.name ILIKE '%' || $search || '%' 
                        OR u.email ILIKE '%' || $search || '%')
  AND ($status IS NULL OR u.user_status = $status::user_status)
  AND ($role IS NULL OR u.user_role = $role::user_role)
GROUP BY u.id
ORDER BY 
  CASE WHEN $sortBy = 'created_at' THEN u.created_at END ASC/DESC,
  CASE WHEN $sortBy = 'name' THEN u.name END ASC/DESC
LIMIT $limit OFFSET $offset;
```

##### **비즈니스 로직**
1. **검색 기능**
   - 이름, 이메일, 전화번호로 검색
   - ILIKE를 사용한 대소문자 무관 검색

2. **필터링 및 정렬**
   - 상태별, 역할별 필터
   - 다양한 컬럼으로 정렬 지원

#### **2.2 PUT /api/admin/users/:userId/status**

##### **요청 구조**
```json
{
  "status": "suspended",
  "reason": "스팸 신고 다수 접수"
}
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 상태 변경
UPDATE public.users SET
    user_status = $status::user_status,
    updated_at = NOW()
WHERE id = $user_id;

-- 관리자 액션 로그 기록
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 'user_suspended', 'user', $user_id, $reason
);
```

### **3. 샵 관리 API**

#### **3.1 GET /api/admin/shops/pending**

##### **데이터베이스 상호작용**
```sql
-- 승인 대기 중인 샵 목록
SELECT s.id, s.name, s.owner_id, s.address, s.main_category,
       s.business_license_number, s.business_license_image_url,
       s.verification_status, s.created_at,
       u.name as owner_name, u.email as owner_email
FROM public.shops s
JOIN public.users u ON s.owner_id = u.id
WHERE s.verification_status = 'pending'
ORDER BY s.created_at ASC;
```

#### **3.2 PUT /api/admin/shops/:shopId/approve**

##### **요청 구조**
```json
{
  "approved": true,
  "shopType": "partnered",
  "commissionRate": 10.0,
  "notes": "승인 완료"
}
```

##### **데이터베이스 상호작용**
```sql
-- 샵 승인 처리
UPDATE public.shops SET
    verification_status = CASE WHEN $approved THEN 'verified' ELSE 'rejected' END,
    shop_status = CASE WHEN $approved THEN 'active' ELSE 'inactive' END,
    shop_type = $shop_type::shop_type,
    commission_rate = $commission_rate,
    partnership_started_at = CASE WHEN $approved THEN NOW() ELSE NULL END
WHERE id = $shop_id;

-- 관리자 액션 로그
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 
    CASE WHEN $approved THEN 'shop_approved' ELSE 'shop_rejected' END,
    'shop', $shop_id, $notes
);
```

##### **비즈니스 로직**
1. **승인 처리**
   - 승인 시 샵 상태를 'active'로 변경
   - 파트너십 타입 및 수수료율 설정

2. **알림 발송**
   - 샵 오너에게 승인/거절 알림 발송
   - 승인 시 환영 메시지 및 가이드 제공

### **4. 예약 관리 API**

#### **4.1 GET /api/admin/reservations**

##### **쿼리 파라미터**
```
?shopId=uuid&status=confirmed&startDate=2024-03-01&endDate=2024-03-31&page=1&limit=50
```

##### **데이터베이스 상호작용**
```sql
-- 예약 목록 조회 (관리자/샵 오너별 권한 적용)
SELECT r.id, r.reservation_date, r.reservation_time, r.status,
       r.total_amount, r.deposit_amount, r.points_used,
       u.name as customer_name, u.phone_number as customer_phone,
       s.name as shop_name, s.id as shop_id,
       array_agg(ss.name) as service_names
FROM public.reservations r
JOIN public.users u ON r.user_id = u.id
JOIN public.shops s ON r.shop_id = s.id
JOIN public.reservation_services rs ON r.id = rs.reservation_id
JOIN public.shop_services ss ON rs.service_id = ss.id
WHERE ($shop_id IS NULL OR r.shop_id = $shop_id)
  AND ($status IS NULL OR r.status = $status::reservation_status)
  AND ($start_date IS NULL OR r.reservation_date >= $start_date)
  AND ($end_date IS NULL OR r.reservation_date <= $end_date)
  AND (
    $admin_role = 'admin' OR 
    (s.owner_id = $admin_id AND $admin_role = 'shop_owner')
  )
GROUP BY r.id, u.id, s.id
ORDER BY r.reservation_datetime DESC
LIMIT $limit OFFSET $offset;
```

#### **4.2 PUT /api/admin/reservations/:reservationId/status**

##### **요청 구조**
```json
{
  "status": "confirmed",
  "notes": "예약 확정되었습니다"
}
```

##### **비즈니스 로직**
1. **상태 변경 권한 확인**
   - Super Admin: 모든 예약 관리 가능
   - Shop Owner: 자신의 샵 예약만 관리

2. **상태별 처리 로직**
   - confirmed: 고객에게 확정 알림
   - completed: 포인트 적립 처리
   - cancelled: 환불 처리 트리거

### **5. 결제 및 정산 API (Super Admin)**

#### **5.1 GET /api/admin/payments/summary**

##### **쿼리 파라미터**
```
?startDate=2024-03-01&endDate=2024-03-31&shopId=uuid
```

##### **데이터베이스 상호작용**
```sql
-- 결제 요약 통계
SELECT 
    DATE_TRUNC('day', p.paid_at) as payment_date,
    COUNT(*) as transaction_count,
    SUM(p.amount) as total_amount,
    SUM(CASE WHEN p.is_deposit THEN p.amount ELSE 0 END) as deposit_amount,
    SUM(CASE WHEN NOT p.is_deposit THEN p.amount ELSE 0 END) as full_payment_amount,
    COUNT(DISTINCT p.user_id) as unique_customers
FROM public.payments p
JOIN public.reservations r ON p.reservation_id = r.id
WHERE p.payment_status = 'fully_paid'
  AND p.paid_at BETWEEN $start_date AND $end_date
  AND ($shop_id IS NULL OR r.shop_id = $shop_id)
GROUP BY DATE_TRUNC('day', p.paid_at)
ORDER BY payment_date DESC;
```

#### **5.2 GET /api/admin/settlements**

##### **데이터베이스 상호작용**
```sql
-- 샵별 정산 내역
SELECT s.id, s.name, s.commission_rate,
       COUNT(r.id) as completed_reservations,
       SUM(r.total_amount) as gross_revenue,
       SUM(r.total_amount * s.commission_rate / 100) as commission_amount,
       SUM(r.total_amount * (100 - s.commission_rate) / 100) as net_payout
FROM public.shops s
JOIN public.reservations r ON s.id = r.shop_id
WHERE r.status = 'completed'
  AND r.completed_at BETWEEN $start_date AND $end_date
  AND s.shop_type = 'partnered'
GROUP BY s.id
ORDER BY gross_revenue DESC;
```

---

## 🔔 알림 시스템

### **푸시 알림 서비스**

#### **FCM 연동 구현**
```typescript
// services/notification.service.ts
class NotificationService {
  async sendPushNotification(
    userId: string, 
    title: string, 
    message: string,
    data?: any
  ) {
    // FCM 토큰 조회
    const tokens = await this.getUserFCMTokens(userId);
    
    // FCM 메시지 발송
    const fcmMessage = {
      notification: { title, body: message },
      data: data || {},
      tokens: tokens
    };
    
    return await admin.messaging().sendMulticast(fcmMessage);
  }
}
```

#### **알림 트리거 이벤트**
1. **예약 관련 알림**
   - 예약 요청 접수: 샵 오너에게 알림
   - 예약 확정: 고객에게 알림
   - 예약 취소: 양측에게 알림

2. **포인트 관련 알림**
   - 포인트 적립: 서비스 완료 후 고객에게
   - 포인트 만료 예정: 만료 7일 전 알림

3. **시스템 알림**
   - 새 공지사항: 전체 사용자
   - 마케팅 정보: 동의한 사용자만

### **실시간 알림 처리**

#### **웹소켓 연결 관리**
```typescript
// WebSocket을 통한 실시간 알림
io.on('connection', (socket) => {
  socket.on('join_admin_room', (adminId) => {
    socket.join(`admin_${adminId}`);
  });
  
  // 새 예약 알림
  socket.on('new_reservation', (data) => {
    io.to(`admin_${data.shopOwnerId}`).emit('reservation_alert', data);
  });
});
```

---

## 📊 분석 및 통계 API

### **대시보드 통계 API**

#### **GET /api/admin/analytics/dashboard**

##### **응답 구조**
```json
{
  "overview": {
    "totalUsers": 15420,
    "totalShops": 234,
    "totalReservations": 3421,
    "totalRevenue": 125000000
  },
  "growth": {
    "userGrowthRate": 12.5,
    "revenueGrowthRate": 8.3,
    "reservationGrowthRate": 15.2
  },
  "chartData": {
    "dailyRegistrations": [...],
    "monthlyRevenue": [...],
    "categoryDistribution": [...]
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 전체 플랫폼 통계
WITH current_month AS (
  SELECT COUNT(*) as users_this_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW())
),
previous_month AS (
  SELECT COUNT(*) as users_last_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW()) - interval '1 month'
    AND created_at < date_trunc('month', NOW())
)
SELECT 
  (SELECT COUNT(*) FROM public.users WHERE user_status = 'active') as total_users,
  (SELECT COUNT(*) FROM public.shops WHERE shop_status = 'active') as total_shops,
  (SELECT COUNT(*) FROM public.reservations) as total_reservations,
  (SELECT SUM(total_amount) FROM public.reservations WHERE status = 'completed') as total_revenue,
  (cm.users_this_month::float / NULLIF(pm.users_last_month, 0) - 1) * 100 as user_growth_rate
FROM current_month cm, previous_month pm;
```

---

## 🛠️ 유틸리티 및 도우미 서비스

### **이메일 서비스**
```typescript
// services/email.service.ts
class EmailService {
  async sendWelcomeEmail(user: User) {
    // 환영 이메일 템플릿 발송
  }
  
  async sendReservationConfirmation(reservation: Reservation) {
    // 예약 확인 이메일 발송
  }
}
```

### **이미지 처리 서비스**
```typescript
// services/image.service.ts
class ImageService {
  async optimizeAndUpload(file: Buffer, path: string) {
    // 이미지 압축 및 Supabase Storage 업로드
    const optimized = await sharp(file)
      .resize(800, 600, { fit: 'inside' })
      .jpeg({ quality: 80 })
      .toBuffer();
      
    return await supabase.storage
      .from('shop-images')
      .upload(path, optimized);
  }
}
```

### **검색 서비스**
```typescript
// services/search.service.ts
class SearchService {
  async searchShops(query: string, filters: SearchFilters) {
    // 전문 검색 기능 구현
    // PostgreSQL Full-Text Search 활용
  }
}
```

---

## 🔧 에러 처리 및 로깅

### **표준화된 에러 응답 형식**
```typescript
// 표준 에러 응답 구조
interface ErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Array<{
      field: string;
      message: string;
    }>;
    timestamp: string;
    requestId: string;
  };
}

// 에러 코드 정의
const ERROR_CODES = {
  // 인증 관련 (1000-1999)
  UNAUTHORIZED: "AUTH_1001",
  TOKEN_EXPIRED: "AUTH_1002",
  INVALID_CREDENTIALS: "AUTH_1003",
  INSUFFICIENT_PERMISSIONS: "AUTH_1004",
  SESSION_TIMEOUT: "AUTH_1005",
  
  // 검증 관련 (2000-2999)
  VALIDATION_ERROR: "VALID_2001",
  MISSING_REQUIRED_FIELD: "VALID_2002",
  INVALID_FORMAT: "VALID_2003",
  INVALID_PHONE_FORMAT: "VALID_2004",
  INVALID_BUSINESS_LICENSE: "VALID_2005",
  
  // 비즈니스 로직 (3000-3999)
  RESOURCE_NOT_FOUND: "BUSINESS_3001",
  INVALID_STATE_TRANSITION: "BUSINESS_3002",
  INSUFFICIENT_POINTS: "BUSINESS_3003",
  SLOT_NOT_AVAILABLE: "BUSINESS_3004",
  CONCURRENT_BOOKING: "BUSINESS_3005",
  POINT_EXPIRED: "BUSINESS_3006",
  
  // 결제 관련 (4000-4999)
  PAYMENT_FAILED: "PAYMENT_4001",
  REFUND_FAILED: "PAYMENT_4002",
  INSUFFICIENT_FUNDS: "PAYMENT_4003",
  PARTIAL_REFUND_NOT_ALLOWED: "PAYMENT_4004",
  
  // 시스템 관련 (5000-5999)
  INTERNAL_SERVER_ERROR: "SYSTEM_5001",
  DATABASE_ERROR: "SYSTEM_5002",
  EXTERNAL_SERVICE_ERROR: "SYSTEM_5003"
};

// 통합 에러 처리
export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  const requestId = req.headers['x-request-id'] as string || generateRequestId();
  
  logger.error({
    message: error.message,
    stack: error.stack,
    path: req.path,
    method: req.method,
    user: req.user?.id,
    requestId
  });
  
  if (error instanceof ValidationError) {
    return res.status(400).json({
      success: false,
      error: {
        code: ERROR_CODES.VALIDATION_ERROR,
        message: "입력 데이터가 올바르지 않습니다",
        details: error.details,
        timestamp: new Date().toISOString(),
        requestId
      }
    });
  }
  
  if (error instanceof AuthenticationError) {
    return res.status(401).json({
      success: false,
      error: {
        code: ERROR_CODES.UNAUTHORIZED,
        message: "인증이 필요합니다",
        timestamp: new Date().toISOString(),
        requestId
      }
    });
  }
  
  // 기본 에러 응답
  return res.status(500).json({
    success: false,
    error: {
      code: ERROR_CODES.INTERNAL_SERVER_ERROR,
      message: "서버 내부 오류가 발생했습니다",
      timestamp: new Date().toISOString(),
      requestId
    }
  });
};
```

### **구조화된 로깅**
```typescript
// utils/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});
```

### **데이터 검증 규칙**
```typescript
// validators/common.validator.ts
import Joi from 'joi';

// 한국 전화번호 검증
export const phoneSchema = Joi.string()
  .pattern(/^01[0-9]-[0-9]{3,4}-[0-9]{4}$/)
  .message('올바른 한국 전화번호 형식이 아닙니다 (예: 010-1234-5678)');

// 사업자등록번호 검증
export const businessLicenseSchema = Joi.string()
  .pattern(/^[0-9]{3}-[0-9]{2}-[0-9]{5}$/)
  .message('올바른 사업자등록번호 형식이 아닙니다 (예: 123-45-67890)');

// 한국 주소 검증
export const addressSchema = Joi.string()
  .min(10)
  .max(200)
  .pattern(/^[가-힣\s]+시\s+[가-힣\s]+구\s+[가-힣\s]+동/)
  .message('올바른 한국 주소 형식이 아닙니다');

// 이미지 업로드 검증
export const imageSchema = Joi.object({
  fieldname: Joi.string().valid('image').required(),
  mimetype: Joi.string().valid('image/jpeg', 'image/png', 'image/webp').required(),
  size: Joi.number().max(5 * 1024 * 1024).required(), // 5MB 제한
  buffer: Joi.binary().required()
});

// 포인트 금액 검증
export const pointAmountSchema = Joi.number()
  .integer()
  .min(1)
  .max(1000000) // 최대 100만 포인트
  .required();
```

### **포인트 시스템 비즈니스 로직**
```typescript
// services/point.service.ts
class PointService {
  // 포인트 만료 처리 (매일 자정 실행)
  async processPointExpiration() {
    const expiredPoints = await supabase
      .from('point_transactions')
      .select('*')
      .eq('status', 'available')
      .lt('expires_at', new Date().toISOString());
    
    for (const point of expiredPoints.data || []) {
      await supabase
        .from('point_transactions')
        .update({ 
          status: 'expired',
          updated_at: new Date().toISOString()
        })
        .eq('id', point.id);
    }
  }
  
  // 7일 후 사용 가능 상태로 변경 (매일 자정 실행)
  async processPendingToAvailable() {
    const pendingPoints = await supabase
      .from('point_transactions')
      .select('*')
      .eq('status', 'pending')
      .lte('available_from', new Date().toISOString());
    
    for (const point of pendingPoints.data || []) {
      await supabase
        .from('point_transactions')
        .update({ 
          status: 'available',
          updated_at: new Date().toISOString()
        })
        .eq('id', point.id);
    }
  }
  
  // 인플루언서 보너스 계산 (2배 적립)
  async calculateInfluencerBonus(userId: string, baseAmount: number) {
    const user = await supabase
      .from('users')
      .select('is_influencer')
      .eq('id', userId)
      .single();
    
    if (user.data?.is_influencer) {
      return baseAmount * 2; // 2배 보너스
    }
    
    return baseAmount;
  }
  
  // 관리자 포인트 조정
  async adjustPointsByAdmin(userId: string, amount: number, reason: string, adminId: string) {
    const transaction = await supabase
      .from('point_transactions')
      .insert({
        user_id: userId,
        transaction_type: 'adjusted',
        amount: amount,
        description: `관리자 조정: ${reason}`,
        status: 'available',
        metadata: { adjusted_by: adminId }
      });
    
    // 관리자 액션 로그 기록
    await supabase
      .from('admin_actions')
      .insert({
        admin_id: adminId,
        action_type: 'points_adjusted',
        target_type: 'user',
        target_id: userId,
        reason: reason,
        metadata: { amount, previous_balance: await this.getUserBalance(userId) }
      });
    
    return transaction;
  }
}
```

### **예약 시스템 비즈니스 로직**
```typescript
// services/reservation.service.ts
class ReservationService {
  // 동시 예약 방지
  async checkConcurrentBooking(shopId: string, date: string, time: string, duration: number) {
    const startTime = new Date(`${date} ${time}`);
    const endTime = new Date(startTime.getTime() + duration * 60000);
    
    const conflictingReservations = await supabase
      .from('reservations')
      .select('*')
      .eq('shop_id', shopId)
      .eq('reservation_date', date)
      .in('status', ['requested', 'confirmed'])
      .overlaps('reservation_datetime', startTime.toISOString(), endTime.toISOString());
    
    return conflictingReservations.data?.length === 0;
  }
  
  // 노쇼 감지 (예약 시간 30분 후 자동 처리)
  async detectNoShow() {
    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
    
    const noShowReservations = await supabase
      .from('reservations')
      .select('*')
      .eq('status', 'confirmed')
      .lt('reservation_datetime', thirtyMinutesAgo.toISOString());
    
    for (const reservation of noShowReservations.data || []) {
      await supabase
        .from('reservations')
        .update({ 
          status: 'no_show',
          no_show_reason: '예약 시간 30분 경과로 노쇼 처리',
          updated_at: new Date().toISOString()
        })
        .eq('id', reservation.id);
    }
  }
  
  // 예약 재스케줄
  async rescheduleReservation(reservationId: string, newDate: string, newTime: string) {
    // 기존 예약 취소
    await this.cancelReservation(reservationId, 'rescheduled');
    
    // 새 예약 생성
    const originalReservation = await supabase
      .from('reservations')
      .select('*')
      .eq('id', reservationId)
      .single();
    
    return await supabase
      .from('reservations')
      .insert({
        user_id: originalReservation.data.user_id,
        shop_id: originalReservation.data.shop_id,
        reservation_date: newDate,
        reservation_time: newTime,
        status: 'requested',
        total_amount: originalReservation.data.total_amount,
        deposit_amount: originalReservation.data.deposit_amount,
        special_requests: originalReservation.data.special_requests
      });
  }
}
```

### **결제 시스템 비즈니스 로직**
```typescript
// services/payment.service.ts
class PaymentService {
  // 부분 환불 처리
  async processPartialRefund(paymentId: string, refundAmount: number, reason: string) {
    const payment = await supabase
      .from('payments')
      .select('*')
      .eq('id', paymentId)
      .single();
    
    if (refundAmount > payment.data.amount) {
      throw new Error('환불 금액이 결제 금액을 초과할 수 없습니다');
    }
    
    const newStatus = refundAmount === payment.data.amount ? 'refunded' : 'partially_refunded';
    
    return await supabase
      .from('payments')
      .update({
        payment_status: newStatus,
        refund_amount: refundAmount,
        refunded_at: new Date().toISOString(),
        metadata: { ...payment.data.metadata, refund_reason: reason }
      })
      .eq('id', paymentId);
  }
  
  // 수수료 계산 (실시간)
  async calculateCommission(shopId: string, amount: number) {
    const shop = await supabase
      .from('shops')
      .select('commission_rate, shop_type')
      .eq('id', shopId)
      .single();
    
    if (shop.data.shop_type === 'partnered') {
      return (amount * shop.data.commission_rate) / 100;
    }
    
    return 0; // 비입점샵은 수수료 없음
  }
  
  // 분할 결제 처리 (예약금 + 잔금)
  async processSplitPayment(reservationId: string, depositAmount: number, totalAmount: number) {
    // 예약금 결제
    const depositPayment = await supabase
      .from('payments')
      .insert({
        reservation_id: reservationId,
        payment_method: 'toss_payments',
        payment_status: 'deposit_paid',
        amount: depositAmount,
        is_deposit: true
      });
    
    // 잔금은 나중에 결제
    const remainingAmount = totalAmount - depositAmount;
    
    return {
      deposit_payment: depositPayment.data,
      remaining_amount: remainingAmount
    };
  }
}
```

---

## 🚀 배포 및 운영

### **환경 설정**
```typescript
// config/database.ts
export const dbConfig = {
  development: {
    url: process.env.SUPABASE_URL_DEV,
    key: process.env.SUPABASE_ANON_KEY_DEV
  },
  production: {
    url: process.env.SUPABASE_URL_PROD,
    key: process.env.SUPABASE_ANON_KEY_PROD
  }
};
```

### **실시간 업데이트 (WebSocket)**
```typescript
// services/websocket.service.ts
import { Server } from 'socket.io';

class WebSocketService {
  private io: Server;
  
  constructor(server: any) {
    this.io = new Server(server, {
      cors: {
        origin: process.env.FRONTEND_URL,
        methods: ["GET", "POST"]
      }
    });
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      // 관리자 인증
      socket.on('admin_auth', async (token) => {
        try {
          const admin = await this.verifyAdminToken(token);
          socket.join(`admin_${admin.id}`);
          socket.emit('auth_success', { adminId: admin.id });
        } catch (error) {
          socket.emit('auth_error', { message: '인증 실패' });
        }
      });
      
      // 샵 오너 인증
      socket.on('shop_owner_auth', async (token) => {
        try {
          const shopOwner = await this.verifyShopOwnerToken(token);
          socket.join(`shop_${shopOwner.shop_id}`);
          socket.emit('auth_success', { shopId: shopOwner.shop_id });
        } catch (error) {
          socket.emit('auth_error', { message: '인증 실패' });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('Client disconnected');
      });
    });
  }
  
  // 실시간 알림 발송
  public sendAdminNotification(adminId: string, notification: any) {
    this.io.to(`admin_${adminId}`).emit('notification', notification);
  }
  
  // 샵 예약 업데이트 알림
  public sendShopReservationUpdate(shopId: string, reservation: any) {
    this.io.to(`shop_${shopId}`).emit('reservation_update', reservation);
  }
  
  // 긴급 알림 (모든 관리자)
  public sendUrgentNotification(notification: any) {
    this.io.to('admin_*').emit('urgent_notification', notification);
  }
}
```

### **캐싱 전략**
```typescript
// services/cache.service.ts
import Redis from 'ioredis';

class CacheService {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
  }
  
  // 샵 정보 캐싱 (1시간)
  async cacheShopInfo(shopId: string, shopData: any) {
    await this.redis.setex(`shop:${shopId}`, 3600, JSON.stringify(shopData));
  }
  
  // 사용자 포인트 캐싱 (5분)
  async cacheUserPoints(userId: string, pointsData: any) {
    await this.redis.setex(`points:${userId}`, 300, JSON.stringify(pointsData));
  }
  
  // 예약 현황 캐싱 (1분)
  async cacheReservationStatus(shopId: string, date: string, status: any) {
    await this.redis.setex(`reservations:${shopId}:${date}`, 60, JSON.stringify(status));
  }
  
  // 캐시 무효화
  async invalidateCache(pattern: string) {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

### **성능 모니터링**
- **APM 도구**: New Relic 또는 DataDog 연동
- **헬스체크**: `/health` 엔드포인트로 서버 상태 확인
- **메트릭 수집**: Prometheus + Grafana 대시보드
- **실시간 모니터링**: WebSocket 연결 수, API 응답 시간, 에러율

### **권한 매트릭스 (Permission Matrix)**
```typescript
// types/permissions.ts
export const PERMISSIONS = {
  // 사용자 관리
  USERS_READ: 'users:read',
  USERS_WRITE: 'users:write',
  USERS_DELETE: 'users:delete',
  USERS_SUSPEND: 'users:suspend',
  
  // 샵 관리
  SHOPS_READ: 'shops:read',
  SHOPS_WRITE: 'shops:write',
  SHOPS_DELETE: 'shops:delete',
  SHOPS_VERIFY: 'shops:verify',
  
  // 예약 관리
  RESERVATIONS_READ: 'reservations:read',
  RESERVATIONS_WRITE: 'reservations:write',
  RESERVATIONS_CANCEL: 'reservations:cancel',
  
  // 결제 관리
  PAYMENTS_READ: 'payments:read',
  PAYMENTS_REFUND: 'payments:refund',
  PAYMENTS_PARTIAL_REFUND: 'payments:partial_refund',
  
  // 포인트 관리
  POINTS_READ: 'points:read',
  POINTS_ADJUST: 'points:adjust',
  
  // 콘텐츠 관리
  CONTENT_READ: 'content:read',
  CONTENT_WRITE: 'content:write',
  CONTENT_DELETE: 'content:delete',
  
  // 시스템 설정
  SYSTEM_READ: 'system:read',
  SYSTEM_WRITE: 'system:write',
  SYSTEM_ADMIN: 'system:admin'
};

// 역할별 권한 정의
export const ROLE_PERMISSIONS = {
  // Super Admin: 모든 권한
  super_admin: Object.values(PERMISSIONS),
  
  // Shop Admin: 자신의 샵 관련 권한만
  shop_admin: [
    PERMISSIONS.USERS_READ,
    PERMISSIONS.SHOPS_READ,
    PERMISSIONS.RESERVATIONS_READ,
    PERMISSIONS.RESERVATIONS_WRITE,
    PERMISSIONS.RESERVATIONS_CANCEL,
    PERMISSIONS.PAYMENTS_READ,
    PERMISSIONS.CONTENT_READ
  ],
  
  // 일반 사용자: 읽기 권한만
  user: [
    PERMISSIONS.USERS_READ,
    PERMISSIONS.SHOPS_READ,
    PERMISSIONS.RESERVATIONS_READ,
    PERMISSIONS.PAYMENTS_READ,
    PERMISSIONS.POINTS_READ,
    PERMISSIONS.CONTENT_READ
  ]
};

// 권한 검증 미들웨어
export const checkPermission = (requiredPermission: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user?.user_role;
    const userPermissions = ROLE_PERMISSIONS[userRole] || [];
    
    if (!userPermissions.includes(requiredPermission)) {
      return res.status(403).json({
        success: false,
        error: {
          code: ERROR_CODES.INSUFFICIENT_PERMISSIONS,
          message: "해당 작업에 대한 권한이 없습니다",
          timestamp: new Date().toISOString(),
          requestId: req.headers['x-request-id'] as string
        }
      });
    }
    
    next();
  };
};
```

### **테스팅 전략 (Testing Strategy)**
```typescript
// tests/integration/api.test.ts
describe('API Integration Tests', () => {
  // 인증 테스트
  describe('Authentication', () => {
    test('should authenticate valid user', async () => {
      const response = await request(app)
        .post('/api/auth/social-login')
        .send({
          provider: 'kakao',
          token: 'valid_token',
          deviceInfo: { platform: 'ios', version: '1.0.0' }
        });
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.jwt_token).toBeDefined();
    });
    
    test('should reject invalid token', async () => {
      const response = await request(app)
        .post('/api/auth/social-login')
        .send({
          provider: 'kakao',
          token: 'invalid_token',
          deviceInfo: { platform: 'ios', version: '1.0.0' }
        });
      
      expect(response.status).toBe(401);
      expect(response.body.error.code).toBe('AUTH_1003');
    });
  });
  
  // 예약 시스템 테스트
  describe('Reservation System', () => {
    test('should prevent concurrent bookings', async () => {
      // 동시 예약 시도 테스트
      const promises = Array(3).fill(null).map(() =>
        request(app)
          .post('/api/reservations')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            shop_id: 'test_shop_id',
            reservation_date: '2024-03-20',
            reservation_time: '14:00',
            services: [{ service_id: 'test_service', quantity: 1 }]
          })
      );
      
      const results = await Promise.all(promises);
      const successful = results.filter(r => r.status === 200);
      
      expect(successful.length).toBe(1); // 하나만 성공해야 함
    });
  });
  
  // 포인트 시스템 테스트
  describe('Point System', () => {
    test('should apply influencer bonus correctly', async () => {
      const response = await request(app)
        .post('/api/points/earn')
        .set('Authorization', `Bearer ${influencerToken}`)
        .send({
          reservation_id: 'test_reservation',
          amount: 1000
        });
      
      expect(response.body.points_earned).toBe(2000); // 2배 보너스
    });
  });
});

// E2E 테스트
describe('End-to-End Tests', () => {
  test('complete reservation flow', async () => {
    // 1. 사용자 로그인
    const loginResponse = await request(app)
      .post('/api/auth/social-login')
      .send(loginData);
    
    const token = loginResponse.body.jwt_token;
    
    // 2. 샵 검색
    const searchResponse = await request(app)
      .get('/api/shops/nearby')
      .set('Authorization', `Bearer ${token}`)
      .query({ latitude: 37.5665, longitude: 126.9780 });
    
    const shopId = searchResponse.body.shops[0].id;
    
    // 3. 예약 생성
    const reservationResponse = await request(app)
      .post('/api/reservations')
      .set('Authorization', `Bearer ${token}`)
      .send({
        shop_id: shopId,
        reservation_date: '2024-03-20',
        reservation_time: '14:00',
        services: [{ service_id: 'test_service', quantity: 1 }]
      });
    
    expect(reservationResponse.status).toBe(200);
    
    // 4. 결제 처리
    const paymentResponse = await request(app)
      .post('/api/payments/toss/prepare')
      .set('Authorization', `Bearer ${token}`)
      .send({
        reservation_id: reservationResponse.body.reservation.id,
        amount: 45000
      });
    
    expect(paymentResponse.status).toBe(200);
  });
});
```

### **모니터링 및 알림 설정 (Monitoring Setup)**
```typescript
// monitoring/health-check.ts
export const healthCheck = {
  // 데이터베이스 연결 상태
  database: async () => {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('count')
        .limit(1);
      
      return {
        status: error ? 'error' : 'healthy',
        response_time: Date.now(),
        error: error?.message
      };
    } catch (error) {
      return {
        status: 'error',
        response_time: Date.now(),
        error: error.message
      };
    }
  },
  
  // 외부 API 상태 (토스페이먼츠)
  external_apis: async () => {
    try {
      const response = await fetch('https://api.tosspayments.com/v1/health');
      return {
        status: response.ok ? 'healthy' : 'error',
        response_time: Date.now(),
        error: response.ok ? null : 'TossPayments API unavailable'
      };
    } catch (error) {
      return {
        status: 'error',
        response_time: Date.now(),
        error: error.message
      };
    }
  },
  
  // 메모리 및 CPU 사용량
  system_resources: () => {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();
    
    return {
      memory: {
        rss: memUsage.rss,
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        external: memUsage.external
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system
      }
    };
  }
};

// 알림 설정
export const alerting = {
  // 에러율 알림
  errorRate: {
    threshold: 0.05, // 5% 이상 에러율
    window: 300000, // 5분 윈도우
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL,
      email: process.env.ALERT_EMAIL
    }
  },
  
  // 응답 시간 알림
  responseTime: {
    threshold: 2000, // 2초 이상
    window: 60000, // 1분 윈도우
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL
    }
  },
  
  // 데이터베이스 연결 실패
  databaseConnection: {
    threshold: 3, // 3회 연속 실패
    window: 60000, // 1분 윈도우
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL,
      email: process.env.ALERT_EMAIL,
      sms: process.env.ALERT_SMS
    }
  }
};

// 메트릭 수집
export const metrics = {
  // API 호출 수
  apiCalls: new Map(),
  
  // 응답 시간
  responseTimes: new Map(),
  
  // 에러 수
  errorCount: new Map(),
  
  // 활성 사용자 수
  activeUsers: new Set(),
  
  // 실시간 예약 수
  activeReservations: 0
};
```

### **보안 강화**
- **HTTPS 강제**: SSL 인증서 적용
- **API 키 관리**: AWS Secrets Manager 또는 환경변수
- **데이터베이스 보안**: RLS 정책 + VPC 네트워크 격리

---

이 설계서는 에뷰리띵 플러터 앱과 웹 관리자 시스템을 지원하는 Node.js 백엔드의 모든 API 엔드포인트, 비즈니스 로직, 데이터베이스 상호작용을 상세히 설명합니다. 개발팀과의 기술 논의 및 구현 가이드로 활용할 수 있도록 구성되었습니다. 