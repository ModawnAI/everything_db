# 에뷰리띵 Node.js 백엔드 서버 상세 설계서

## 📱 개요
본 문서는 에뷰리띵 플러터 앱과 웹 관리자 시스템을 지원하는 Node.js 백엔드 서버의 모든 API 엔드포인트, 미들웨어, 비즈니스 로직에 대한 상세한 기능 정의와 Supabase 데이터베이스와의 상호작용을 설명합니다.

---

## 🏗️ 아키텍처 개요

### **기술 스택 및 프레임워크**
- **런타임**: Node.js 18+ LTS (최신 안정 버전)
- **프레임워크**: Express.js 4.18+ (RESTful API 구축)
- **언어**: TypeScript 5.0+ (타입 안전성 보장)
- **데이터베이스**: Supabase PostgreSQL (PostGIS 확장 포함)
- **인증**: Supabase Auth + JWT 토큰 검증
- **결제**: 토스페이먼츠 API 연동
- **푸시알림**: Firebase Cloud Messaging (FCM)
- **파일 스토리지**: Supabase Storage
- **로깅**: Winston + Morgan (구조화된 로그)
- **문서화**: Swagger/OpenAPI 3.0
- **환경관리**: dotenv + config 패턴

### **서버 구조 및 디렉토리**
```
src/
├── controllers/          # API 컨트롤러 (요청/응답 처리)
├── services/            # 비즈니스 로직 서비스
├── repositories/        # 데이터 접근 계층
├── middleware/          # 미들웨어 (인증, 검증, 로깅)
├── routes/             # API 라우트 정의
├── types/              # TypeScript 타입 정의
├── utils/              # 유틸리티 함수들
├── config/             # 설정 파일들
├── validators/         # 요청 데이터 검증
├── constants/          # 상수 정의
└── app.ts             # Express 앱 진입점
```

### **데이터 플로우 아키텍처**
```
Flutter App / Web Admin
         ↓
    Express Router
         ↓
   Authentication Middleware
         ↓
   Request Validation
         ↓
    Controller Layer
         ↓
    Service Layer (비즈니스 로직)
         ↓
   Repository Layer
         ↓
    Supabase Client
         ↓
   PostgreSQL Database
```

---

## 🔐 인증 및 보안 시스템

### **인증 미들웨어 구현**

#### **JWT 토큰 검증 미들웨어**
```typescript
// middleware/auth.middleware.ts
```

#### **기능 및 로직**
1. **토큰 추출 및 검증**
   - Authorization 헤더에서 Bearer 토큰 추출
   - Supabase JWT 시크릿으로 토큰 검증
   - 만료 시간 확인 및 페이로드 파싱

2. **사용자 정보 로드**
   - 토큰의 sub (사용자 ID)로 사용자 정보 조회
   - `user_status`가 'active'인지 확인
   - `req.user`에 사용자 정보 저장

3. **에러 처리**
   - 토큰 없음: 401 Unauthorized
   - 유효하지 않은 토큰: 401 Unauthorized  
   - 비활성 사용자: 403 Forbidden

#### **역할 기반 접근 제어 (RBAC)**
```typescript
// middleware/authorization.middleware.ts
```

#### **관리자 권한 검증**
1. **역할 확인**
   - `user_role` 필드 검증 ('admin', 'shop_owner', 'user')
   - 요청된 리소스에 대한 권한 매트릭스 확인

2. **샵 소유자 권한**
   - 샵 관련 API 접근 시 `owner_id` 일치 확인
   - 자신의 샵 데이터만 접근 가능하도록 제한

#### **Rate Limiting 및 보안**
```typescript
// middleware/rateLimiter.middleware.ts
```

1. **API 속도 제한**
   - 사용자별 분당 요청 수 제한 (기본: 100req/min)
   - 로그인 API는 더 엄격한 제한 (5req/min)
   - Redis 또는 메모리 기반 카운터 사용

2. **보안 헤더**
   - Helmet.js로 기본 보안 헤더 설정
   - CORS 정책 설정 (허용된 도메인만)
   - XSS, CSRF 보호 헤더 적용

---

## 📱 플러터 앱 API 엔드포인트

### **1. 사용자 인증 관련 API**

#### **1.1 POST /api/auth/social-login**

##### **요청 구조**
```json
{
  "provider": "kakao|apple|google",
  "token": "소셜_로그인_토큰",
  "deviceInfo": {
    "platform": "ios|android",
    "version": "앱_버전",
    "deviceId": "기기_고유_ID"
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 신규 사용자 생성 또는 기존 사용자 업데이트
INSERT INTO public.users (
    id, email, name, social_provider, social_provider_id,
    referral_code, last_login_at
) VALUES (
    $user_id, $email, $name, $provider, $provider_id,
    generate_referral_code(), NOW()
) ON CONFLICT (id) DO UPDATE SET
    last_login_at = NOW();

-- FCM 토큰 등록/업데이트
INSERT INTO public.push_tokens (user_id, token, platform)
VALUES ($user_id, $fcm_token, $platform)
ON CONFLICT (user_id, token) DO UPDATE SET
    last_used_at = NOW();
```

##### **비즈니스 로직**
1. **소셜 토큰 검증**
   - 각 제공자별 토큰 검증 API 호출
   - 사용자 기본 정보 추출 (이메일, 이름)

2. **Supabase Auth 연동**
   - 소셜 로그인 정보로 Supabase 사용자 생성/로그인
   - JWT 토큰 발급 및 반환

3. **기기 정보 저장**
   - FCM 토큰 등록 (푸시 알림용)
   - 기기별 로그인 이력 추적

#### **1.2 POST /api/auth/register**

##### **요청 구조**
```json
{
  "name": "사용자_실명",
  "gender": "male|female|other|prefer_not_to_say",
  "birthDate": "1990-01-01",
  "phoneNumber": "010-1234-5678",
  "phoneVerified": true,
  "referralCode": "ABCD1234",
  "termsAccepted": true,
  "privacyAccepted": true,
  "marketingConsent": false
}
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 정보 업데이트
UPDATE public.users SET
    name = $name,
    gender = $gender::user_gender,
    birth_date = $birth_date,
    phone_number = $phone_number,
    phone_verified = $phone_verified,
    referred_by_code = $referral_code,
    terms_accepted_at = NOW(),
    privacy_accepted_at = NOW(),
    marketing_consent = $marketing_consent
WHERE id = auth.uid();

-- 추천인 통계 업데이트
UPDATE public.users SET 
    total_referrals = total_referrals + 1
WHERE referral_code = $referred_by_code;
```

##### **비즈니스 로직**
1. **입력 데이터 검증**
   - Joi 스키마로 모든 필드 검증
   - 전화번호 형식 검증 (한국 형식)
   - 생년월일 유효성 검사

2. **추천인 코드 처리**
   - 입력된 추천인 코드 존재 여부 확인
   - 추천인의 `total_referrals` 카운트 증가
   - 추천 관계 기록 저장

### **2. 홈 화면 관련 API**

#### **2.1 GET /api/shops/nearby**

##### **쿼리 파라미터**
```
?latitude=37.5665&longitude=126.9780&radius=10000&limit=30&offset=0&category=nail&partnered=true
```

##### **데이터베이스 상호작용**
```sql
-- 위치 기반 샵 조회 (PRD 2.1 알고리즘 적용)
SELECT s.*, 
       ST_Distance(s.location, ST_Point($longitude, $latitude)::geography) as distance,
       COUNT(r.id) as total_bookings,
       AVG(rv.rating) as average_rating,
       si.image_url as main_image
FROM public.shops s
LEFT JOIN public.reservations r ON s.id = r.shop_id
LEFT JOIN public.reviews rv ON s.id = rv.shop_id AND rv.status = 'active'
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE s.shop_status = 'active'
  AND ST_DWithin(s.location, ST_Point($longitude, $latitude)::geography, $radius)
  AND ($category IS NULL OR s.main_category = $category::service_category)
  AND ($partnered IS NULL OR s.shop_type = CASE WHEN $partnered THEN 'partnered' ELSE 'non_partnered' END)
GROUP BY s.id, si.image_url
ORDER BY 
  CASE WHEN s.shop_type = 'partnered' THEN 0 ELSE 1 END,
  s.partnership_started_at DESC,
  distance ASC
LIMIT $limit OFFSET $offset;
```

##### **비즈니스 로직**
1. **위치 기반 필터링**
   - PostGIS `ST_DWithin` 함수로 지정 반경 내 샵 조회
   - GPS 좌표를 GEOGRAPHY 타입으로 변환

2. **우선 순위 알고리즘**
   - 입점샵 (`shop_type = 'partnered'`) 최우선 노출
   - 입점샵 내에서는 최신 입점순 정렬
   - 비입점샵은 거리순 정렬

3. **성능 최적화**
   - 공간 인덱스 활용으로 빠른 위치 검색
   - 페이징으로 초기 로딩 시간 단축

#### **2.2 GET /api/user/favorites**

##### **데이터베이스 상호작용**
```sql
-- 사용자 즐겨찾기 샵 조회
SELECT s.*, uf.created_at as favorited_at,
       si.image_url as main_image
FROM public.user_favorites uf
JOIN public.shops s ON uf.shop_id = s.id
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE uf.user_id = $user_id AND s.shop_status = 'active'
ORDER BY uf.created_at DESC;
```

##### **비즈니스 로직**
- JWT 토큰에서 사용자 ID 추출
- 즐겨찾기한 순서대로 정렬
- 비활성화된 샵은 제외

### **3. 샵 상세 정보 API**

#### **3.1 GET /api/shops/:shopId**

##### **데이터베이스 상호작용**
```sql
-- 샵 상세 정보 조회
SELECT s.*,
       array_agg(DISTINCT si.image_url ORDER BY si.display_order) as shop_images,
       COUNT(DISTINCT r.id) as total_reviews,
       AVG(rv.rating) as average_rating,
       COUNT(DISTINCT res.id) as total_bookings
FROM public.shops s
LEFT JOIN public.shop_images si ON s.id = si.shop_id
LEFT JOIN public.reviews r ON s.id = r.shop_id AND r.status = 'active'
LEFT JOIN public.reservations res ON s.id = res.shop_id
WHERE s.id = $shop_id AND s.shop_status = 'active'
GROUP BY s.id;

-- 샵 서비스 목록
SELECT ss.*, 
       array_agg(ssi.image_url ORDER BY ssi.display_order) as service_images
FROM public.shop_services ss
LEFT JOIN public.service_images ssi ON ss.id = ssi.service_id
WHERE ss.shop_id = $shop_id AND ss.is_available = true
GROUP BY ss.id
ORDER BY ss.display_order, ss.category;
```

##### **비즈니스 로직**
1. **종합 정보 제공**
   - 샵 기본 정보 + 이미지 + 통계 데이터 통합
   - 서비스별 이미지와 가격 정보 포함

2. **영업시간 계산**
   - `operating_hours` JSONB 파싱
   - 현재 시간 기준 영업 상태 계산

#### **3.2 POST /api/shops/:shopId/favorite**

##### **데이터베이스 상호작용**
```sql
-- 즐겨찾기 추가/제거 토글
INSERT INTO public.user_favorites (user_id, shop_id)
VALUES ($user_id, $shop_id)
ON CONFLICT (user_id, shop_id) DO NOTHING;

-- 즐겨찾기 제거 (이미 존재하는 경우)
DELETE FROM public.user_favorites 
WHERE user_id = $user_id AND shop_id = $shop_id;
```

##### **비즈니스 로직**
- 현재 즐겨찾기 상태 확인 후 토글
- 동시성 제어를 위한 트랜잭션 처리

### **4. 예약 시스템 API**

#### **4.1 GET /api/shops/:shopId/available-slots**

##### **쿼리 파라미터**
```
?date=2024-03-15&serviceIds[]=uuid1&serviceIds[]=uuid2
```

##### **데이터베이스 상호작용**
```sql
-- 예약 가능한 시간 슬롯 조회
WITH time_slots AS (
    SELECT generate_series(
        $date::date + interval '9 hours',
        $date::date + interval '18 hours',
        interval '30 minutes'
    ) as slot_time
),
booked_slots AS (
    SELECT reservation_datetime
    FROM public.reservations
    WHERE shop_id = $shop_id 
      AND reservation_date = $date
      AND status IN ('confirmed', 'requested')
),
service_duration AS (
    SELECT MAX(duration_minutes) as max_duration
    FROM public.shop_services
    WHERE id = ANY($service_ids)
)
SELECT ts.slot_time
FROM time_slots ts
CROSS JOIN service_duration sd
WHERE NOT EXISTS (
    SELECT 1 FROM booked_slots bs
    WHERE bs.reservation_datetime BETWEEN 
        ts.slot_time AND ts.slot_time + (sd.max_duration || ' minutes')::interval
);
```

##### **비즈니스 로직**
1. **시간 슬롯 생성**
   - 영업시간 기반 30분 간격 슬롯 생성
   - 선택된 서비스 소요시간 고려

2. **예약 충돌 방지**
   - 기존 예약과 겹치는 시간 제외
   - 서비스 소요시간만큼 버퍼 적용

#### **4.2 POST /api/reservations**

##### **요청 구조**
```json
{
  "shopId": "uuid",
  "services": [
    {
      "serviceId": "uuid",
      "quantity": 1
    }
  ],
  "reservationDate": "2024-03-15",
  "reservationTime": "14:00",
  "specialRequests": "특별 요청사항",
  "pointsToUse": 5000
}
```

##### **데이터베이스 상호작용**
```sql
-- 예약 생성 트랜잭션
BEGIN;

-- 예약 메인 정보 생성
INSERT INTO public.reservations (
    user_id, shop_id, reservation_date, reservation_time,
    total_amount, deposit_amount, points_used, special_requests,
    status
) VALUES (
    $user_id, $shop_id, $date, $time,
    $total_amount, $deposit_amount, $points_used, $requests,
    'requested'
) RETURNING id;

-- 예약 서비스 연결
INSERT INTO public.reservation_services (
    reservation_id, service_id, quantity, unit_price, total_price
) VALUES ($reservation_id, $service_id, $quantity, $unit_price, $total_price);

-- 포인트 사용 처리
INSERT INTO public.point_transactions (
    user_id, reservation_id, transaction_type, amount, status
) VALUES (
    $user_id, $reservation_id, 'used_service', -$points_used, 'available'
);

COMMIT;
```

##### **비즈니스 로직**
1. **가격 계산**
   - 선택된 서비스들의 총액 계산
   - 포인트 할인 적용 (사용 가능 포인트 확인)
   - 예약금 비율 계산 (보통 20-30%)

2. **재고 및 시간 확인**
   - 요청된 시간 슬롯 재확인
   - 동시 예약 방지를 위한 락 처리

3. **알림 발송**
   - 사용자에게 예약 요청 완료 알림
   - 샵 사장에게 새 예약 요청 알림

### **5. 결제 시스템 API**

#### **5.1 POST /api/payments/toss/prepare**

##### **요청 구조**
```json
{
  "reservationId": "uuid",
  "paymentMethod": "toss_payments",
  "amount": 50000,
  "isDeposit": true
}
```

##### **토스페이먼츠 연동**
```typescript
// 토스페이먼츠 결제 준비
const tossResponse = await fetch('https://api.tosspayments.com/v1/payments', {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    amount: amount,
    orderId: `order_${reservationId}_${Date.now()}`,
    orderName: `에뷰리띵 예약금 결제`,
    customerName: user.name,
    customerEmail: user.email
  })
});
```

##### **데이터베이스 상호작용**
```sql
-- 결제 정보 생성
INSERT INTO public.payments (
    reservation_id, user_id, payment_method, amount,
    payment_provider, provider_order_id, is_deposit,
    payment_status
) VALUES (
    $reservation_id, $user_id, $payment_method, $amount,
    'toss_payments', $order_id, $is_deposit,
    'pending'
) RETURNING id;
```

#### **5.2 POST /api/payments/toss/confirm**

##### **토스페이먼츠 결제 승인**
```typescript
const confirmResponse = await fetch(`https://api.tosspayments.com/v1/payments/confirm`, {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    paymentKey: paymentKey,
    orderId: orderId,
    amount: amount
  })
});
```

##### **결제 완료 후 처리**
```sql
-- 결제 상태 업데이트
UPDATE public.payments SET
    payment_status = 'deposit_paid',
    provider_transaction_id = $transaction_id,
    paid_at = NOW()
WHERE provider_order_id = $order_id;

-- 예약 상태 업데이트  
UPDATE public.reservations SET
    status = 'confirmed'
WHERE id = $reservation_id;

-- 서비스 포인트 적립 (예약 완료 시)
SELECT award_service_points($reservation_id);
```

### **6. 포인트 시스템 API**

#### **6.1 GET /api/user/points**

##### **응답 구조**
```json
{
  "totalPoints": 15000,
  "availablePoints": 12000,
  "pendingPoints": 3000,
  "pointsThisMonth": 5000,
  "transactions": [...]
}
```

##### **데이터베이스 상호작용**
```sql
-- 포인트 요약 정보 조회
SELECT u.total_points, u.available_points,
       COALESCE(pending.pending_points, 0) as pending_points,
       COALESCE(this_month.points_this_month, 0) as points_this_month
FROM public.users u
LEFT JOIN (
    SELECT user_id, SUM(amount) as pending_points
    FROM public.point_transactions 
    WHERE status = 'pending' AND amount > 0
    GROUP BY user_id
) pending ON u.id = pending.user_id
LEFT JOIN (
    SELECT user_id, SUM(amount) as points_this_month
    FROM public.point_transactions 
    WHERE status = 'available' AND amount > 0
      AND created_at >= date_trunc('month', NOW())
    GROUP BY user_id
) this_month ON u.id = this_month.user_id
WHERE u.id = $user_id;
```

#### **6.2 POST /api/points/use**

##### **요청 구조**
```json
{
  "amount": 5000,
  "reservationId": "uuid",
  "description": "서비스 결제 사용"
}
```

##### **비즈니스 로직**
1. **사용 가능 포인트 확인**
   - 7일 제한 규칙 적용
   - 만료되지 않은 포인트만 사용

2. **포인트 차감 처리**
   - 선입선출(FIFO) 방식으로 차감
   - 트랜잭션으로 원자성 보장

---

## 🖥️ 웹 관리자 API 엔드포인트

### **1. 관리자 인증 API**

#### **1.1 POST /api/admin/login**

##### **요청 구조**
```json
{
  "email": "admin@ebeautything.com",
  "password": "secure_password"
}
```

##### **데이터베이스 상호작용**
```sql
-- 관리자 계정 확인
SELECT id, email, name, user_role 
FROM public.users 
WHERE email = $email 
  AND user_role IN ('admin', 'shop_owner')
  AND user_status = 'active';
```

##### **비즈니스 로직**
1. **이메일/비밀번호 검증**
   - Supabase Auth로 인증 처리
   - 관리자 역할 확인

2. **세션 관리**
   - JWT 토큰 발급 (longer expiry for admin)
   - 로그인 이력 기록

### **2. 사용자 관리 API (Super Admin)**

#### **2.1 GET /api/admin/users**

##### **쿼리 파라미터**
```
?page=1&limit=50&search=홍길동&status=active&role=user&sortBy=created_at&sortOrder=desc
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 목록 조회 (검색 및 필터 적용)
SELECT u.id, u.name, u.email, u.phone_number, u.user_status, 
       u.user_role, u.is_influencer, u.total_points, u.total_referrals,
       u.created_at, u.last_login_at,
       COUNT(r.id) as total_reservations
FROM public.users u
LEFT JOIN public.reservations r ON u.id = r.user_id
WHERE ($search IS NULL OR u.name ILIKE '%' || $search || '%' 
                        OR u.email ILIKE '%' || $search || '%')
  AND ($status IS NULL OR u.user_status = $status::user_status)
  AND ($role IS NULL OR u.user_role = $role::user_role)
GROUP BY u.id
ORDER BY 
  CASE WHEN $sortBy = 'created_at' THEN u.created_at END ASC/DESC,
  CASE WHEN $sortBy = 'name' THEN u.name END ASC/DESC
LIMIT $limit OFFSET $offset;
```

##### **비즈니스 로직**
1. **검색 기능**
   - 이름, 이메일, 전화번호로 검색
   - ILIKE를 사용한 대소문자 무관 검색

2. **필터링 및 정렬**
   - 상태별, 역할별 필터
   - 다양한 컬럼으로 정렬 지원

#### **2.2 PUT /api/admin/users/:userId/status**

##### **요청 구조**
```json
{
  "status": "suspended",
  "reason": "스팸 신고 다수 접수"
}
```

##### **데이터베이스 상호작용**
```sql
-- 사용자 상태 변경
UPDATE public.users SET
    user_status = $status::user_status,
    updated_at = NOW()
WHERE id = $user_id;

-- 관리자 액션 로그 기록
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 'user_suspended', 'user', $user_id, $reason
);
```

### **3. 샵 관리 API**

#### **3.1 GET /api/admin/shops/pending**

##### **데이터베이스 상호작용**
```sql
-- 승인 대기 중인 샵 목록
SELECT s.id, s.name, s.owner_id, s.address, s.main_category,
       s.business_license_number, s.business_license_image_url,
       s.verification_status, s.created_at,
       u.name as owner_name, u.email as owner_email
FROM public.shops s
JOIN public.users u ON s.owner_id = u.id
WHERE s.verification_status = 'pending'
ORDER BY s.created_at ASC;
```

#### **3.2 PUT /api/admin/shops/:shopId/approve**

##### **요청 구조**
```json
{
  "approved": true,
  "shopType": "partnered",
  "commissionRate": 10.0,
  "notes": "승인 완료"
}
```

##### **데이터베이스 상호작용**
```sql
-- 샵 승인 처리
UPDATE public.shops SET
    verification_status = CASE WHEN $approved THEN 'verified' ELSE 'rejected' END,
    shop_status = CASE WHEN $approved THEN 'active' ELSE 'inactive' END,
    shop_type = $shop_type::shop_type,
    commission_rate = $commission_rate,
    partnership_started_at = CASE WHEN $approved THEN NOW() ELSE NULL END
WHERE id = $shop_id;

-- 관리자 액션 로그
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 
    CASE WHEN $approved THEN 'shop_approved' ELSE 'shop_rejected' END,
    'shop', $shop_id, $notes
);
```

##### **비즈니스 로직**
1. **승인 처리**
   - 승인 시 샵 상태를 'active'로 변경
   - 파트너십 타입 및 수수료율 설정

2. **알림 발송**
   - 샵 오너에게 승인/거절 알림 발송
   - 승인 시 환영 메시지 및 가이드 제공

### **4. 예약 관리 API**

#### **4.1 GET /api/admin/reservations**

##### **쿼리 파라미터**
```
?shopId=uuid&status=confirmed&startDate=2024-03-01&endDate=2024-03-31&page=1&limit=50
```

##### **데이터베이스 상호작용**
```sql
-- 예약 목록 조회 (관리자/샵 오너별 권한 적용)
SELECT r.id, r.reservation_date, r.reservation_time, r.status,
       r.total_amount, r.deposit_amount, r.points_used,
       u.name as customer_name, u.phone_number as customer_phone,
       s.name as shop_name, s.id as shop_id,
       array_agg(ss.name) as service_names
FROM public.reservations r
JOIN public.users u ON r.user_id = u.id
JOIN public.shops s ON r.shop_id = s.id
JOIN public.reservation_services rs ON r.id = rs.reservation_id
JOIN public.shop_services ss ON rs.service_id = ss.id
WHERE ($shop_id IS NULL OR r.shop_id = $shop_id)
  AND ($status IS NULL OR r.status = $status::reservation_status)
  AND ($start_date IS NULL OR r.reservation_date >= $start_date)
  AND ($end_date IS NULL OR r.reservation_date <= $end_date)
  AND (
    $admin_role = 'admin' OR 
    (s.owner_id = $admin_id AND $admin_role = 'shop_owner')
  )
GROUP BY r.id, u.id, s.id
ORDER BY r.reservation_datetime DESC
LIMIT $limit OFFSET $offset;
```

#### **4.2 PUT /api/admin/reservations/:reservationId/status**

##### **요청 구조**
```json
{
  "status": "confirmed",
  "notes": "예약 확정되었습니다"
}
```

##### **비즈니스 로직**
1. **상태 변경 권한 확인**
   - Super Admin: 모든 예약 관리 가능
   - Shop Owner: 자신의 샵 예약만 관리

2. **상태별 처리 로직**
   - confirmed: 고객에게 확정 알림
   - completed: 포인트 적립 처리
   - cancelled: 환불 처리 트리거

### **5. 결제 및 정산 API (Super Admin)**

#### **5.1 GET /api/admin/payments/summary**

##### **쿼리 파라미터**
```
?startDate=2024-03-01&endDate=2024-03-31&shopId=uuid
```

##### **데이터베이스 상호작용**
```sql
-- 결제 요약 통계
SELECT 
    DATE_TRUNC('day', p.paid_at) as payment_date,
    COUNT(*) as transaction_count,
    SUM(p.amount) as total_amount,
    SUM(CASE WHEN p.is_deposit THEN p.amount ELSE 0 END) as deposit_amount,
    SUM(CASE WHEN NOT p.is_deposit THEN p.amount ELSE 0 END) as full_payment_amount,
    COUNT(DISTINCT p.user_id) as unique_customers
FROM public.payments p
JOIN public.reservations r ON p.reservation_id = r.id
WHERE p.payment_status = 'fully_paid'
  AND p.paid_at BETWEEN $start_date AND $end_date
  AND ($shop_id IS NULL OR r.shop_id = $shop_id)
GROUP BY DATE_TRUNC('day', p.paid_at)
ORDER BY payment_date DESC;
```

#### **5.2 GET /api/admin/settlements**

##### **데이터베이스 상호작용**
```sql
-- 샵별 정산 내역
SELECT s.id, s.name, s.commission_rate,
       COUNT(r.id) as completed_reservations,
       SUM(r.total_amount) as gross_revenue,
       SUM(r.total_amount * s.commission_rate / 100) as commission_amount,
       SUM(r.total_amount * (100 - s.commission_rate) / 100) as net_payout
FROM public.shops s
JOIN public.reservations r ON s.id = r.shop_id
WHERE r.status = 'completed'
  AND r.completed_at BETWEEN $start_date AND $end_date
  AND s.shop_type = 'partnered'
GROUP BY s.id
ORDER BY gross_revenue DESC;
```

---

## 🔔 알림 시스템

### **푸시 알림 서비스**

#### **FCM 연동 구현**
```typescript
// services/notification.service.ts
class NotificationService {
  async sendPushNotification(
    userId: string, 
    title: string, 
    message: string,
    data?: any
  ) {
    // FCM 토큰 조회
    const tokens = await this.getUserFCMTokens(userId);
    
    // FCM 메시지 발송
    const fcmMessage = {
      notification: { title, body: message },
      data: data || {},
      tokens: tokens
    };
    
    return await admin.messaging().sendMulticast(fcmMessage);
  }
}
```

#### **알림 트리거 이벤트**
1. **예약 관련 알림**
   - 예약 요청 접수: 샵 오너에게 알림
   - 예약 확정: 고객에게 알림
   - 예약 취소: 양측에게 알림

2. **포인트 관련 알림**
   - 포인트 적립: 서비스 완료 후 고객에게
   - 포인트 만료 예정: 만료 7일 전 알림

3. **시스템 알림**
   - 새 공지사항: 전체 사용자
   - 마케팅 정보: 동의한 사용자만

### **실시간 알림 처리**

#### **웹소켓 연결 관리**
```typescript
// WebSocket을 통한 실시간 알림
io.on('connection', (socket) => {
  socket.on('join_admin_room', (adminId) => {
    socket.join(`admin_${adminId}`);
  });
  
  // 새 예약 알림
  socket.on('new_reservation', (data) => {
    io.to(`admin_${data.shopOwnerId}`).emit('reservation_alert', data);
  });
});
```

---

## 📊 분석 및 통계 API

### **대시보드 통계 API**

#### **GET /api/admin/analytics/dashboard**

##### **응답 구조**
```json
{
  "overview": {
    "totalUsers": 15420,
    "totalShops": 234,
    "totalReservations": 3421,
    "totalRevenue": 125000000
  },
  "growth": {
    "userGrowthRate": 12.5,
    "revenueGrowthRate": 8.3,
    "reservationGrowthRate": 15.2
  },
  "chartData": {
    "dailyRegistrations": [...],
    "monthlyRevenue": [...],
    "categoryDistribution": [...]
  }
}
```

##### **데이터베이스 상호작용**
```sql
-- 전체 플랫폼 통계
WITH current_month AS (
  SELECT COUNT(*) as users_this_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW())
),
previous_month AS (
  SELECT COUNT(*) as users_last_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW()) - interval '1 month'
    AND created_at < date_trunc('month', NOW())
)
SELECT 
  (SELECT COUNT(*) FROM public.users WHERE user_status = 'active') as total_users,
  (SELECT COUNT(*) FROM public.shops WHERE shop_status = 'active') as total_shops,
  (SELECT COUNT(*) FROM public.reservations) as total_reservations,
  (SELECT SUM(total_amount) FROM public.reservations WHERE status = 'completed') as total_revenue,
  (cm.users_this_month::float / NULLIF(pm.users_last_month, 0) - 1) * 100 as user_growth_rate
FROM current_month cm, previous_month pm;
```

---

## 🛠️ 유틸리티 및 도우미 서비스

### **이메일 서비스**
```typescript
// services/email.service.ts
class EmailService {
  async sendWelcomeEmail(user: User) {
    // 환영 이메일 템플릿 발송
  }
  
  async sendReservationConfirmation(reservation: Reservation) {
    // 예약 확인 이메일 발송
  }
}
```

### **이미지 처리 서비스**
```typescript
// services/image.service.ts
class ImageService {
  async optimizeAndUpload(file: Buffer, path: string) {
    // 이미지 압축 및 Supabase Storage 업로드
    const optimized = await sharp(file)
      .resize(800, 600, { fit: 'inside' })
      .jpeg({ quality: 80 })
      .toBuffer();
      
    return await supabase.storage
      .from('shop-images')
      .upload(path, optimized);
  }
}
```

### **검색 서비스**
```typescript
// services/search.service.ts
class SearchService {
  async searchShops(query: string, filters: SearchFilters) {
    // 전문 검색 기능 구현
    // PostgreSQL Full-Text Search 활용
  }
}
```

---

## 🔧 에러 처리 및 로깅

### **통합 에러 처리**
```typescript
// middleware/errorHandler.middleware.ts
export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  logger.error({
    message: error.message,
    stack: error.stack,
    path: req.path,
    method: req.method,
    user: req.user?.id
  });
  
  if (error instanceof ValidationError) {
    return res.status(400).json({
      error: 'VALIDATION_ERROR',
      message: error.message,
      details: error.details
    });
  }
  
  // 기타 에러 처리...
};
```

### **구조화된 로깅**
```typescript
// utils/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});
```

---

## 🚀 배포 및 운영

### **환경 설정**
```typescript
// config/database.ts
export const dbConfig = {
  development: {
    url: process.env.SUPABASE_URL_DEV,
    key: process.env.SUPABASE_ANON_KEY_DEV
  },
  production: {
    url: process.env.SUPABASE_URL_PROD,
    key: process.env.SUPABASE_ANON_KEY_PROD
  }
};
```

### **성능 모니터링**
- **APM 도구**: New Relic 또는 DataDog 연동
- **헬스체크**: `/health` 엔드포인트로 서버 상태 확인
- **메트릭 수집**: Prometheus + Grafana 대시보드

### **보안 강화**
- **HTTPS 강제**: SSL 인증서 적용
- **API 키 관리**: AWS Secrets Manager 또는 환경변수
- **데이터베이스 보안**: RLS 정책 + VPC 네트워크 격리

---

이 설계서는 에뷰리띵 플러터 앱과 웹 관리자 시스템을 지원하는 Node.js 백엔드의 모든 API 엔드포인트, 비즈니스 로직, 데이터베이스 상호작용을 상세히 설명합니다. 개발팀과의 기술 논의 및 구현 가이드로 활용할 수 있도록 구성되었습니다. 