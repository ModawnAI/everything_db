# ì—ë·°ë¦¬ëµ Node.js ë°±ì—”ë“œ ì„œë²„ ìƒì„¸ ì„¤ê³„ì„œ

## ðŸ“± ê°œìš”
ë³¸ ë¬¸ì„œëŠ” ì—ë·°ë¦¬ëµ í”ŒëŸ¬í„° ì•±ê³¼ ì›¹ ê´€ë¦¬ìž ì‹œìŠ¤í…œì„ ì§€ì›í•˜ëŠ” Node.js ë°±ì—”ë“œ ì„œë²„ì˜ ëª¨ë“  API ì—”ë“œí¬ì¸íŠ¸, ë¯¸ë“¤ì›¨ì–´, ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ëŒ€í•œ ìƒì„¸í•œ ê¸°ëŠ¥ ì •ì˜ì™€ Supabase ë°ì´í„°ë² ì´ìŠ¤ì™€ì˜ ìƒí˜¸ìž‘ìš©ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

---

## ðŸ—ï¸ ì•„í‚¤í…ì²˜ ê°œìš”

### **ê¸°ìˆ  ìŠ¤íƒ ë° í”„ë ˆìž„ì›Œí¬**
- **ëŸ°íƒ€ìž„**: Node.js 18+ LTS (ìµœì‹  ì•ˆì • ë²„ì „)
- **í”„ë ˆìž„ì›Œí¬**: Express.js 4.18+ (RESTful API êµ¬ì¶•)
- **ì–¸ì–´**: TypeScript 5.0+ (íƒ€ìž… ì•ˆì „ì„± ë³´ìž¥)
- **ë°ì´í„°ë² ì´ìŠ¤**: Supabase PostgreSQL (PostGIS í™•ìž¥ í¬í•¨)
- **ì¸ì¦**: Supabase Auth + JWT í† í° ê²€ì¦
- **ê²°ì œ**: í† ìŠ¤íŽ˜ì´ë¨¼ì¸  API ì—°ë™
- **í‘¸ì‹œì•Œë¦¼**: Firebase Cloud Messaging (FCM)
- **íŒŒì¼ ìŠ¤í† ë¦¬ì§€**: Supabase Storage
- **ë¡œê¹…**: Winston + Morgan (êµ¬ì¡°í™”ëœ ë¡œê·¸)
- **ë¬¸ì„œí™”**: Swagger/OpenAPI 3.0
- **í™˜ê²½ê´€ë¦¬**: dotenv + config íŒ¨í„´

### **ì„œë²„ êµ¬ì¡° ë° ë””ë ‰í† ë¦¬**
```
src/
â”œâ”€â”€ controllers/          # API ì»¨íŠ¸ë¡¤ëŸ¬ (ìš”ì²­/ì‘ë‹µ ì²˜ë¦¬)
â”œâ”€â”€ services/            # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì„œë¹„ìŠ¤
â”œâ”€â”€ repositories/        # ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ
â”œâ”€â”€ middleware/          # ë¯¸ë“¤ì›¨ì–´ (ì¸ì¦, ê²€ì¦, ë¡œê¹…)
â”œâ”€â”€ routes/             # API ë¼ìš°íŠ¸ ì •ì˜
â”œâ”€â”€ types/              # TypeScript íƒ€ìž… ì •ì˜
â”œâ”€â”€ utils/              # ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
â”œâ”€â”€ config/             # ì„¤ì • íŒŒì¼ë“¤
â”œâ”€â”€ validators/         # ìš”ì²­ ë°ì´í„° ê²€ì¦
â”œâ”€â”€ constants/          # ìƒìˆ˜ ì •ì˜
â””â”€â”€ app.ts             # Express ì•± ì§„ìž…ì 
```

### **ë°ì´í„° í”Œë¡œìš° ì•„í‚¤í…ì²˜**
```
Flutter App / Web Admin
         â†“
    Express Router
         â†“
   Authentication Middleware
         â†“
   Request Validation
         â†“
    Controller Layer
         â†“
    Service Layer (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
         â†“
   Repository Layer
         â†“
    Supabase Client
         â†“
   PostgreSQL Database
```

---

## ðŸ” ì¸ì¦ ë° ë³´ì•ˆ ì‹œìŠ¤í…œ

### **ì¸ì¦ ë¯¸ë“¤ì›¨ì–´ êµ¬í˜„**

#### **JWT í† í° ê²€ì¦ ë¯¸ë“¤ì›¨ì–´**
```typescript
// middleware/auth.middleware.ts
```

#### **ê¸°ëŠ¥ ë° ë¡œì§**
1. **í† í° ì¶”ì¶œ ë° ê²€ì¦**
   - Authorization í—¤ë”ì—ì„œ Bearer í† í° ì¶”ì¶œ
   - Supabase JWT ì‹œí¬ë¦¿ìœ¼ë¡œ í† í° ê²€ì¦
   - ë§Œë£Œ ì‹œê°„ í™•ì¸ ë° íŽ˜ì´ë¡œë“œ íŒŒì‹±

2. **ì‚¬ìš©ìž ì •ë³´ ë¡œë“œ**
   - í† í°ì˜ sub (ì‚¬ìš©ìž ID)ë¡œ ì‚¬ìš©ìž ì •ë³´ ì¡°íšŒ
   - `user_status`ê°€ 'active'ì¸ì§€ í™•ì¸
   - `req.user`ì— ì‚¬ìš©ìž ì •ë³´ ì €ìž¥

3. **ì—ëŸ¬ ì²˜ë¦¬**
   - í† í° ì—†ìŒ: 401 Unauthorized
   - ìœ íš¨í•˜ì§€ ì•Šì€ í† í°: 401 Unauthorized  
   - ë¹„í™œì„± ì‚¬ìš©ìž: 403 Forbidden

#### **ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´ (RBAC)**
```typescript
// middleware/authorization.middleware.ts
```

#### **ê´€ë¦¬ìž ê¶Œí•œ ê²€ì¦**
1. **ì—­í•  í™•ì¸**
   - `user_role` í•„ë“œ ê²€ì¦ ('admin', 'shop_owner', 'user')
   - ìš”ì²­ëœ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ê¶Œí•œ ë§¤íŠ¸ë¦­ìŠ¤ í™•ì¸

2. **ìƒµ ì†Œìœ ìž ê¶Œí•œ**
   - ìƒµ ê´€ë ¨ API ì ‘ê·¼ ì‹œ `owner_id` ì¼ì¹˜ í™•ì¸
   - ìžì‹ ì˜ ìƒµ ë°ì´í„°ë§Œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ ì œí•œ

#### **Rate Limiting ë° ë³´ì•ˆ**
```typescript
// middleware/rateLimiter.middleware.ts
```

1. **API ì†ë„ ì œí•œ**
   - ì‚¬ìš©ìžë³„ ë¶„ë‹¹ ìš”ì²­ ìˆ˜ ì œí•œ (ê¸°ë³¸: 100req/min)
   - ë¡œê·¸ì¸ APIëŠ” ë” ì—„ê²©í•œ ì œí•œ (5req/min)
   - Redis ë˜ëŠ” ë©”ëª¨ë¦¬ ê¸°ë°˜ ì¹´ìš´í„° ì‚¬ìš©

2. **ë³´ì•ˆ í—¤ë”**
   - Helmet.jsë¡œ ê¸°ë³¸ ë³´ì•ˆ í—¤ë” ì„¤ì •
   - CORS ì •ì±… ì„¤ì • (í—ˆìš©ëœ ë„ë©”ì¸ë§Œ)
   - XSS, CSRF ë³´í˜¸ í—¤ë” ì ìš©

---

## ðŸ“± í”ŒëŸ¬í„° ì•± API ì—”ë“œí¬ì¸íŠ¸

### **1. ì‚¬ìš©ìž ì¸ì¦ ê´€ë ¨ API**

#### **1.1 POST /api/auth/social-login**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "provider": "kakao|apple|google",
  "token": "ì†Œì…œ_ë¡œê·¸ì¸_í† í°",
  "deviceInfo": {
    "platform": "ios|android",
    "version": "ì•±_ë²„ì „",
    "deviceId": "ê¸°ê¸°_ê³ ìœ _ID"
  }
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì‹ ê·œ ì‚¬ìš©ìž ìƒì„± ë˜ëŠ” ê¸°ì¡´ ì‚¬ìš©ìž ì—…ë°ì´íŠ¸
INSERT INTO public.users (
    id, email, name, social_provider, social_provider_id,
    referral_code, last_login_at
) VALUES (
    $user_id, $email, $name, $provider, $provider_id,
    generate_referral_code(), NOW()
) ON CONFLICT (id) DO UPDATE SET
    last_login_at = NOW();

-- FCM í† í° ë“±ë¡/ì—…ë°ì´íŠ¸
INSERT INTO public.push_tokens (user_id, token, platform)
VALUES ($user_id, $fcm_token, $platform)
ON CONFLICT (user_id, token) DO UPDATE SET
    last_used_at = NOW();
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ì†Œì…œ í† í° ê²€ì¦**
   - ê° ì œê³µìžë³„ í† í° ê²€ì¦ API í˜¸ì¶œ
   - ì‚¬ìš©ìž ê¸°ë³¸ ì •ë³´ ì¶”ì¶œ (ì´ë©”ì¼, ì´ë¦„)

2. **Supabase Auth ì—°ë™**
   - ì†Œì…œ ë¡œê·¸ì¸ ì •ë³´ë¡œ Supabase ì‚¬ìš©ìž ìƒì„±/ë¡œê·¸ì¸
   - JWT í† í° ë°œê¸‰ ë° ë°˜í™˜

3. **ê¸°ê¸° ì •ë³´ ì €ìž¥**
   - FCM í† í° ë“±ë¡ (í‘¸ì‹œ ì•Œë¦¼ìš©)
   - ê¸°ê¸°ë³„ ë¡œê·¸ì¸ ì´ë ¥ ì¶”ì 

#### **1.2 POST /api/auth/register**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "name": "ì‚¬ìš©ìž_ì‹¤ëª…",
  "gender": "male|female|other|prefer_not_to_say",
  "birthDate": "1990-01-01",
  "phoneNumber": "010-1234-5678",
  "phoneVerified": true,
  "referralCode": "ABCD1234",
  "termsAccepted": true,
  "privacyAccepted": true,
  "marketingConsent": false
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì‚¬ìš©ìž ì •ë³´ ì—…ë°ì´íŠ¸
UPDATE public.users SET
    name = $name,
    gender = $gender::user_gender,
    birth_date = $birth_date,
    phone_number = $phone_number,
    phone_verified = $phone_verified,
    referred_by_code = $referral_code,
    terms_accepted_at = NOW(),
    privacy_accepted_at = NOW(),
    marketing_consent = $marketing_consent
WHERE id = auth.uid();

-- ì¶”ì²œì¸ í†µê³„ ì—…ë°ì´íŠ¸
UPDATE public.users SET 
    total_referrals = total_referrals + 1
WHERE referral_code = $referred_by_code;
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ìž…ë ¥ ë°ì´í„° ê²€ì¦**
   - Joi ìŠ¤í‚¤ë§ˆë¡œ ëª¨ë“  í•„ë“œ ê²€ì¦
   - ì „í™”ë²ˆí˜¸ í˜•ì‹ ê²€ì¦ (í•œêµ­ í˜•ì‹)
   - ìƒë…„ì›”ì¼ ìœ íš¨ì„± ê²€ì‚¬

2. **ì¶”ì²œì¸ ì½”ë“œ ì²˜ë¦¬**
   - ìž…ë ¥ëœ ì¶”ì²œì¸ ì½”ë“œ ì¡´ìž¬ ì—¬ë¶€ í™•ì¸
   - ì¶”ì²œì¸ì˜ `total_referrals` ì¹´ìš´íŠ¸ ì¦ê°€
   - ì¶”ì²œ ê´€ê³„ ê¸°ë¡ ì €ìž¥

### **2. í™ˆ í™”ë©´ ê´€ë ¨ API**

#### **2.1 GET /api/shops/nearby**

##### **ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°**
```
?latitude=37.5665&longitude=126.9780&radius=10000&limit=30&offset=0&category=nail&partnered=true
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ìœ„ì¹˜ ê¸°ë°˜ ìƒµ ì¡°íšŒ (PRD 2.1 ì•Œê³ ë¦¬ì¦˜ ì ìš©)
SELECT s.*, 
       ST_Distance(s.location, ST_Point($longitude, $latitude)::geography) as distance,
       COUNT(r.id) as total_bookings,
       AVG(rv.rating) as average_rating,
       si.image_url as main_image
FROM public.shops s
LEFT JOIN public.reservations r ON s.id = r.shop_id
LEFT JOIN public.reviews rv ON s.id = rv.shop_id AND rv.status = 'active'
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE s.shop_status = 'active'
  AND ST_DWithin(s.location, ST_Point($longitude, $latitude)::geography, $radius)
  AND ($category IS NULL OR s.main_category = $category::service_category)
  AND ($partnered IS NULL OR s.shop_type = CASE WHEN $partnered THEN 'partnered' ELSE 'non_partnered' END)
GROUP BY s.id, si.image_url
ORDER BY 
  CASE WHEN s.shop_type = 'partnered' THEN 0 ELSE 1 END,
  s.partnership_started_at DESC,
  distance ASC
LIMIT $limit OFFSET $offset;
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ìœ„ì¹˜ ê¸°ë°˜ í•„í„°ë§**
   - PostGIS `ST_DWithin` í•¨ìˆ˜ë¡œ ì§€ì • ë°˜ê²½ ë‚´ ìƒµ ì¡°íšŒ
   - GPS ì¢Œí‘œë¥¼ GEOGRAPHY íƒ€ìž…ìœ¼ë¡œ ë³€í™˜

2. **ìš°ì„  ìˆœìœ„ ì•Œê³ ë¦¬ì¦˜**
   - ìž…ì ìƒµ (`shop_type = 'partnered'`) ìµœìš°ì„  ë…¸ì¶œ
   - ìž…ì ìƒµ ë‚´ì—ì„œëŠ” ìµœì‹  ìž…ì ìˆœ ì •ë ¬
   - ë¹„ìž…ì ìƒµì€ ê±°ë¦¬ìˆœ ì •ë ¬

3. **ì„±ëŠ¥ ìµœì í™”**
   - ê³µê°„ ì¸ë±ìŠ¤ í™œìš©ìœ¼ë¡œ ë¹ ë¥¸ ìœ„ì¹˜ ê²€ìƒ‰
   - íŽ˜ì´ì§•ìœ¼ë¡œ ì´ˆê¸° ë¡œë”© ì‹œê°„ ë‹¨ì¶•

#### **2.2 GET /api/user/favorites**

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì‚¬ìš©ìž ì¦ê²¨ì°¾ê¸° ìƒµ ì¡°íšŒ
SELECT s.*, uf.created_at as favorited_at,
       si.image_url as main_image
FROM public.user_favorites uf
JOIN public.shops s ON uf.shop_id = s.id
LEFT JOIN public.shop_images si ON s.id = si.shop_id AND si.is_primary = true
WHERE uf.user_id = $user_id AND s.shop_status = 'active'
ORDER BY uf.created_at DESC;
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
- JWT í† í°ì—ì„œ ì‚¬ìš©ìž ID ì¶”ì¶œ
- ì¦ê²¨ì°¾ê¸°í•œ ìˆœì„œëŒ€ë¡œ ì •ë ¬
- ë¹„í™œì„±í™”ëœ ìƒµì€ ì œì™¸

### **3. ìƒµ ìƒì„¸ ì •ë³´ API**

#### **3.1 GET /api/shops/:shopId**

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ìƒµ ìƒì„¸ ì •ë³´ ì¡°íšŒ
SELECT s.*,
       array_agg(DISTINCT si.image_url ORDER BY si.display_order) as shop_images,
       COUNT(DISTINCT r.id) as total_reviews,
       AVG(rv.rating) as average_rating,
       COUNT(DISTINCT res.id) as total_bookings
FROM public.shops s
LEFT JOIN public.shop_images si ON s.id = si.shop_id
LEFT JOIN public.reviews r ON s.id = r.shop_id AND r.status = 'active'
LEFT JOIN public.reservations res ON s.id = res.shop_id
WHERE s.id = $shop_id AND s.shop_status = 'active'
GROUP BY s.id;

-- ìƒµ ì„œë¹„ìŠ¤ ëª©ë¡
SELECT ss.*, 
       array_agg(ssi.image_url ORDER BY ssi.display_order) as service_images
FROM public.shop_services ss
LEFT JOIN public.service_images ssi ON ss.id = ssi.service_id
WHERE ss.shop_id = $shop_id AND ss.is_available = true
GROUP BY ss.id
ORDER BY ss.display_order, ss.category;
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ì¢…í•© ì •ë³´ ì œê³µ**
   - ìƒµ ê¸°ë³¸ ì •ë³´ + ì´ë¯¸ì§€ + í†µê³„ ë°ì´í„° í†µí•©
   - ì„œë¹„ìŠ¤ë³„ ì´ë¯¸ì§€ì™€ ê°€ê²© ì •ë³´ í¬í•¨

2. **ì˜ì—…ì‹œê°„ ê³„ì‚°**
   - `operating_hours` JSONB íŒŒì‹±
   - í˜„ìž¬ ì‹œê°„ ê¸°ì¤€ ì˜ì—… ìƒíƒœ ê³„ì‚°

#### **3.2 POST /api/shops/:shopId/favorite**

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì¦ê²¨ì°¾ê¸° ì¶”ê°€/ì œê±° í† ê¸€
INSERT INTO public.user_favorites (user_id, shop_id)
VALUES ($user_id, $shop_id)
ON CONFLICT (user_id, shop_id) DO NOTHING;

-- ì¦ê²¨ì°¾ê¸° ì œê±° (ì´ë¯¸ ì¡´ìž¬í•˜ëŠ” ê²½ìš°)
DELETE FROM public.user_favorites 
WHERE user_id = $user_id AND shop_id = $shop_id;
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
- í˜„ìž¬ ì¦ê²¨ì°¾ê¸° ìƒíƒœ í™•ì¸ í›„ í† ê¸€
- ë™ì‹œì„± ì œì–´ë¥¼ ìœ„í•œ íŠ¸ëžœìž­ì…˜ ì²˜ë¦¬

### **4. ì˜ˆì•½ ì‹œìŠ¤í…œ API**

#### **4.1 GET /api/shops/:shopId/available-slots**

##### **ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°**
```
?date=2024-03-15&serviceIds[]=uuid1&serviceIds[]=uuid2
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì˜ˆì•½ ê°€ëŠ¥í•œ ì‹œê°„ ìŠ¬ë¡¯ ì¡°íšŒ
WITH time_slots AS (
    SELECT generate_series(
        $date::date + interval '9 hours',
        $date::date + interval '18 hours',
        interval '30 minutes'
    ) as slot_time
),
booked_slots AS (
    SELECT reservation_datetime
    FROM public.reservations
    WHERE shop_id = $shop_id 
      AND reservation_date = $date
      AND status IN ('confirmed', 'requested')
),
service_duration AS (
    SELECT MAX(duration_minutes) as max_duration
    FROM public.shop_services
    WHERE id = ANY($service_ids)
)
SELECT ts.slot_time
FROM time_slots ts
CROSS JOIN service_duration sd
WHERE NOT EXISTS (
    SELECT 1 FROM booked_slots bs
    WHERE bs.reservation_datetime BETWEEN 
        ts.slot_time AND ts.slot_time + (sd.max_duration || ' minutes')::interval
);
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ì‹œê°„ ìŠ¬ë¡¯ ìƒì„±**
   - ì˜ì—…ì‹œê°„ ê¸°ë°˜ 30ë¶„ ê°„ê²© ìŠ¬ë¡¯ ìƒì„±
   - ì„ íƒëœ ì„œë¹„ìŠ¤ ì†Œìš”ì‹œê°„ ê³ ë ¤

2. **ì˜ˆì•½ ì¶©ëŒ ë°©ì§€**
   - ê¸°ì¡´ ì˜ˆì•½ê³¼ ê²¹ì¹˜ëŠ” ì‹œê°„ ì œì™¸
   - ì„œë¹„ìŠ¤ ì†Œìš”ì‹œê°„ë§Œí¼ ë²„í¼ ì ìš©

#### **4.2 POST /api/reservations**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "shopId": "uuid",
  "services": [
    {
      "serviceId": "uuid",
      "quantity": 1
    }
  ],
  "reservationDate": "2024-03-15",
  "reservationTime": "14:00",
  "specialRequests": "íŠ¹ë³„ ìš”ì²­ì‚¬í•­",
  "pointsToUse": 5000
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì˜ˆì•½ ìƒì„± íŠ¸ëžœìž­ì…˜
BEGIN;

-- ì˜ˆì•½ ë©”ì¸ ì •ë³´ ìƒì„±
INSERT INTO public.reservations (
    user_id, shop_id, reservation_date, reservation_time,
    total_amount, deposit_amount, points_used, special_requests,
    status
) VALUES (
    $user_id, $shop_id, $date, $time,
    $total_amount, $deposit_amount, $points_used, $requests,
    'requested'
) RETURNING id;

-- ì˜ˆì•½ ì„œë¹„ìŠ¤ ì—°ê²°
INSERT INTO public.reservation_services (
    reservation_id, service_id, quantity, unit_price, total_price
) VALUES ($reservation_id, $service_id, $quantity, $unit_price, $total_price);

-- í¬ì¸íŠ¸ ì‚¬ìš© ì²˜ë¦¬
INSERT INTO public.point_transactions (
    user_id, reservation_id, transaction_type, amount, status
) VALUES (
    $user_id, $reservation_id, 'used_service', -$points_used, 'available'
);

COMMIT;
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ê°€ê²© ê³„ì‚°**
   - ì„ íƒëœ ì„œë¹„ìŠ¤ë“¤ì˜ ì´ì•¡ ê³„ì‚°
   - í¬ì¸íŠ¸ í• ì¸ ì ìš© (ì‚¬ìš© ê°€ëŠ¥ í¬ì¸íŠ¸ í™•ì¸)
   - ì˜ˆì•½ê¸ˆ ë¹„ìœ¨ ê³„ì‚° (ë³´í†µ 20-30%)

2. **ìž¬ê³  ë° ì‹œê°„ í™•ì¸**
   - ìš”ì²­ëœ ì‹œê°„ ìŠ¬ë¡¯ ìž¬í™•ì¸
   - ë™ì‹œ ì˜ˆì•½ ë°©ì§€ë¥¼ ìœ„í•œ ë½ ì²˜ë¦¬

3. **ì•Œë¦¼ ë°œì†¡**
   - ì‚¬ìš©ìžì—ê²Œ ì˜ˆì•½ ìš”ì²­ ì™„ë£Œ ì•Œë¦¼
   - ìƒµ ì‚¬ìž¥ì—ê²Œ ìƒˆ ì˜ˆì•½ ìš”ì²­ ì•Œë¦¼

### **5. ê²°ì œ ì‹œìŠ¤í…œ API**

#### **5.1 POST /api/payments/toss/prepare**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "reservationId": "uuid",
  "paymentMethod": "toss_payments",
  "amount": 50000,
  "isDeposit": true
}
```

##### **í† ìŠ¤íŽ˜ì´ë¨¼ì¸  ì—°ë™**
```typescript
// í† ìŠ¤íŽ˜ì´ë¨¼ì¸  ê²°ì œ ì¤€ë¹„
const tossResponse = await fetch('https://api.tosspayments.com/v1/payments', {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    amount: amount,
    orderId: `order_${reservationId}_${Date.now()}`,
    orderName: `ì—ë·°ë¦¬ëµ ì˜ˆì•½ê¸ˆ ê²°ì œ`,
    customerName: user.name,
    customerEmail: user.email
  })
});
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ê²°ì œ ì •ë³´ ìƒì„±
INSERT INTO public.payments (
    reservation_id, user_id, payment_method, amount,
    payment_provider, provider_order_id, is_deposit,
    payment_status
) VALUES (
    $reservation_id, $user_id, $payment_method, $amount,
    'toss_payments', $order_id, $is_deposit,
    'pending'
) RETURNING id;
```

#### **5.2 POST /api/payments/toss/confirm**

##### **í† ìŠ¤íŽ˜ì´ë¨¼ì¸  ê²°ì œ ìŠ¹ì¸**
```typescript
const confirmResponse = await fetch(`https://api.tosspayments.com/v1/payments/confirm`, {
  method: 'POST',
  headers: {
    'Authorization': `Basic ${Buffer.from(tossSecretKey + ':').toString('base64')}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    paymentKey: paymentKey,
    orderId: orderId,
    amount: amount
  })
});
```

##### **ê²°ì œ ì™„ë£Œ í›„ ì²˜ë¦¬**
```sql
-- ê²°ì œ ìƒíƒœ ì—…ë°ì´íŠ¸
UPDATE public.payments SET
    payment_status = 'deposit_paid',
    provider_transaction_id = $transaction_id,
    paid_at = NOW()
WHERE provider_order_id = $order_id;

-- ì˜ˆì•½ ìƒíƒœ ì—…ë°ì´íŠ¸  
UPDATE public.reservations SET
    status = 'confirmed'
WHERE id = $reservation_id;

-- ì„œë¹„ìŠ¤ í¬ì¸íŠ¸ ì ë¦½ (ì˜ˆì•½ ì™„ë£Œ ì‹œ)
SELECT award_service_points($reservation_id);
```

### **6. í¬ì¸íŠ¸ ì‹œìŠ¤í…œ API**

#### **6.1 GET /api/user/points**

##### **ì‘ë‹µ êµ¬ì¡°**
```json
{
  "totalPoints": 15000,
  "availablePoints": 12000,
  "pendingPoints": 3000,
  "pointsThisMonth": 5000,
  "transactions": [...]
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- í¬ì¸íŠ¸ ìš”ì•½ ì •ë³´ ì¡°íšŒ
SELECT u.total_points, u.available_points,
       COALESCE(pending.pending_points, 0) as pending_points,
       COALESCE(this_month.points_this_month, 0) as points_this_month
FROM public.users u
LEFT JOIN (
    SELECT user_id, SUM(amount) as pending_points
    FROM public.point_transactions 
    WHERE status = 'pending' AND amount > 0
    GROUP BY user_id
) pending ON u.id = pending.user_id
LEFT JOIN (
    SELECT user_id, SUM(amount) as points_this_month
    FROM public.point_transactions 
    WHERE status = 'available' AND amount > 0
      AND created_at >= date_trunc('month', NOW())
    GROUP BY user_id
) this_month ON u.id = this_month.user_id
WHERE u.id = $user_id;
```

#### **6.2 POST /api/points/use**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "amount": 5000,
  "reservationId": "uuid",
  "description": "ì„œë¹„ìŠ¤ ê²°ì œ ì‚¬ìš©"
}
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ì‚¬ìš© ê°€ëŠ¥ í¬ì¸íŠ¸ í™•ì¸**
   - 7ì¼ ì œí•œ ê·œì¹™ ì ìš©
   - ë§Œë£Œë˜ì§€ ì•Šì€ í¬ì¸íŠ¸ë§Œ ì‚¬ìš©

2. **í¬ì¸íŠ¸ ì°¨ê° ì²˜ë¦¬**
   - ì„ ìž…ì„ ì¶œ(FIFO) ë°©ì‹ìœ¼ë¡œ ì°¨ê°
   - íŠ¸ëžœìž­ì…˜ìœ¼ë¡œ ì›ìžì„± ë³´ìž¥

#### **6.3 POST /api/admin/points/adjust**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "userId": "uuid",
  "amount": 5000,
  "reason": "ê³ ê° ë¬¸ì˜ë¡œ ì¸í•œ í¬ì¸íŠ¸ ë³´ìƒ",
  "type": "add" // "add" ë˜ëŠ” "subtract"
}
```

##### **ì‘ë‹µ êµ¬ì¡°**
```json
{
  "success": true,
  "message": "í¬ì¸íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ì¡°ì •ë˜ì—ˆìŠµë‹ˆë‹¤",
  "adjustment": {
    "id": "uuid",
    "userId": "uuid",
    "amount": 5000,
    "type": "add",
    "reason": "ê³ ê° ë¬¸ì˜ë¡œ ì¸í•œ í¬ì¸íŠ¸ ë³´ìƒ",
    "previousBalance": 15000,
    "newBalance": 20000,
    "adjustedBy": "admin_uuid",
    "created_at": "2024-03-15T16:30:00Z"
  }
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- í¬ì¸íŠ¸ ì¡°ì • íŠ¸ëžœìž­ì…˜
BEGIN;

-- í¬ì¸íŠ¸ ê±°ëž˜ ë‚´ì—­ ìƒì„±
INSERT INTO public.point_transactions (
    user_id, transaction_type, amount, description, 
    status, metadata
) VALUES (
    $user_id, 'adjusted', $amount, $description,
    'available', jsonb_build_object('adjusted_by', $admin_id)
);

-- ê´€ë¦¬ìž ì•¡ì…˜ ë¡œê·¸ ê¸°ë¡
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id,
    reason, metadata
) VALUES (
    $admin_id, 'points_adjusted', 'user', $user_id,
    $reason, jsonb_build_object('amount', $amount)
);

COMMIT;
```

#### **6.4 POST /api/admin/payments/partial-refund**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "paymentId": "uuid",
  "refundAmount": 25000,
  "reason": "ê³ ê° ìš”ì²­ìœ¼ë¡œ ì¸í•œ ë¶€ë¶„ í™˜ë¶ˆ",
  "refundMethod": "original" // "original" ë˜ëŠ” "points"
}
```

##### **ì‘ë‹µ êµ¬ì¡°**
```json
{
  "success": true,
  "message": "ë¶€ë¶„ í™˜ë¶ˆì´ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤",
  "refund": {
    "id": "uuid",
    "paymentId": "uuid",
    "refundAmount": 25000,
    "reason": "ê³ ê° ìš”ì²­ìœ¼ë¡œ ì¸í•œ ë¶€ë¶„ í™˜ë¶ˆ",
    "refundMethod": "original",
    "status": "partially_refunded",
    "processedAt": "2024-03-15T16:30:00Z"
  }
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ë¶€ë¶„ í™˜ë¶ˆ ì²˜ë¦¬
UPDATE public.payments 
SET payment_status = CASE 
    WHEN $refund_amount = amount THEN 'refunded'
    ELSE 'partially_refunded'
  END,
    refund_amount = $refund_amount,
    refunded_at = NOW(),
    metadata = jsonb_set(
      metadata, 
      '{refund_reason}', 
      to_jsonb($reason)
    )
WHERE id = $payment_id;

-- ê´€ë¦¬ìž ì•¡ì…˜ ë¡œê·¸ ê¸°ë¡
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id,
    reason, metadata
) VALUES (
    $admin_id, 'refund_processed', 'payment', $payment_id,
    $reason, jsonb_build_object('refund_amount', $refund_amount)
);
```

---

## ðŸ–¥ï¸ ì›¹ ê´€ë¦¬ìž API ì—”ë“œí¬ì¸íŠ¸

### **1. ê´€ë¦¬ìž ì¸ì¦ API**

#### **1.1 POST /api/admin/login**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "email": "admin@ebeautything.com",
  "password": "secure_password"
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ê´€ë¦¬ìž ê³„ì • í™•ì¸
SELECT id, email, name, user_role 
FROM public.users 
WHERE email = $email 
  AND user_role IN ('admin', 'shop_owner')
  AND user_status = 'active';
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ì´ë©”ì¼/ë¹„ë°€ë²ˆí˜¸ ê²€ì¦**
   - Supabase Authë¡œ ì¸ì¦ ì²˜ë¦¬
   - ê´€ë¦¬ìž ì—­í•  í™•ì¸

2. **ì„¸ì…˜ ê´€ë¦¬**
   - JWT í† í° ë°œê¸‰ (longer expiry for admin)
   - ë¡œê·¸ì¸ ì´ë ¥ ê¸°ë¡
   - ë‹¤ì¤‘ ë””ë°”ì´ìŠ¤ ë¡œê·¸ì¸ ì •ì±… (ìµœëŒ€ 3ê°œ ë””ë°”ì´ìŠ¤)
   - ìžë™ í† í° ê°±ì‹  (30ë¶„ ê°„ê²©)

3. **ë³´ì•ˆ ê°•í™”**
   - ë¡œê·¸ì¸ ì‹œë„ ì œí•œ (5íšŒ ì‹¤íŒ¨ ì‹œ 30ë¶„ ìž ê¸ˆ)
   - IP ê¸°ë°˜ ì ‘ê·¼ ì œí•œ (ê´€ë¦¬ìž ì „ìš© IP ì„¤ì • ê°€ëŠ¥)
   - ì„¸ì…˜ íƒ€ìž„ì•„ì›ƒ (1ì‹œê°„ ë¹„í™œì„± ì‹œ ìžë™ ë¡œê·¸ì•„ì›ƒ)

### **2. ì‚¬ìš©ìž ê´€ë¦¬ API (Super Admin)**

#### **2.1 GET /api/admin/users**

##### **ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°**
```
?page=1&limit=50&search=í™ê¸¸ë™&status=active&role=user&sortBy=created_at&sortOrder=desc
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì‚¬ìš©ìž ëª©ë¡ ì¡°íšŒ (ê²€ìƒ‰ ë° í•„í„° ì ìš©)
SELECT u.id, u.name, u.email, u.phone_number, u.user_status, 
       u.user_role, u.is_influencer, u.total_points, u.total_referrals,
       u.created_at, u.last_login_at,
       COUNT(r.id) as total_reservations
FROM public.users u
LEFT JOIN public.reservations r ON u.id = r.user_id
WHERE ($search IS NULL OR u.name ILIKE '%' || $search || '%' 
                        OR u.email ILIKE '%' || $search || '%')
  AND ($status IS NULL OR u.user_status = $status::user_status)
  AND ($role IS NULL OR u.user_role = $role::user_role)
GROUP BY u.id
ORDER BY 
  CASE WHEN $sortBy = 'created_at' THEN u.created_at END ASC/DESC,
  CASE WHEN $sortBy = 'name' THEN u.name END ASC/DESC
LIMIT $limit OFFSET $offset;
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ê²€ìƒ‰ ê¸°ëŠ¥**
   - ì´ë¦„, ì´ë©”ì¼, ì „í™”ë²ˆí˜¸ë¡œ ê²€ìƒ‰
   - ILIKEë¥¼ ì‚¬ìš©í•œ ëŒ€ì†Œë¬¸ìž ë¬´ê´€ ê²€ìƒ‰

2. **í•„í„°ë§ ë° ì •ë ¬**
   - ìƒíƒœë³„, ì—­í• ë³„ í•„í„°
   - ë‹¤ì–‘í•œ ì»¬ëŸ¼ìœ¼ë¡œ ì •ë ¬ ì§€ì›

#### **2.2 PUT /api/admin/users/:userId/status**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "status": "suspended",
  "reason": "ìŠ¤íŒ¸ ì‹ ê³  ë‹¤ìˆ˜ ì ‘ìˆ˜"
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì‚¬ìš©ìž ìƒíƒœ ë³€ê²½
UPDATE public.users SET
    user_status = $status::user_status,
    updated_at = NOW()
WHERE id = $user_id;

-- ê´€ë¦¬ìž ì•¡ì…˜ ë¡œê·¸ ê¸°ë¡
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 'user_suspended', 'user', $user_id, $reason
);
```

### **3. ìƒµ ê´€ë¦¬ API**

#### **3.1 GET /api/admin/shops/pending**

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ìŠ¹ì¸ ëŒ€ê¸° ì¤‘ì¸ ìƒµ ëª©ë¡
SELECT s.id, s.name, s.owner_id, s.address, s.main_category,
       s.business_license_number, s.business_license_image_url,
       s.verification_status, s.created_at,
       u.name as owner_name, u.email as owner_email
FROM public.shops s
JOIN public.users u ON s.owner_id = u.id
WHERE s.verification_status = 'pending'
ORDER BY s.created_at ASC;
```

#### **3.2 PUT /api/admin/shops/:shopId/approve**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "approved": true,
  "shopType": "partnered",
  "commissionRate": 10.0,
  "notes": "ìŠ¹ì¸ ì™„ë£Œ"
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ìƒµ ìŠ¹ì¸ ì²˜ë¦¬
UPDATE public.shops SET
    verification_status = CASE WHEN $approved THEN 'verified' ELSE 'rejected' END,
    shop_status = CASE WHEN $approved THEN 'active' ELSE 'inactive' END,
    shop_type = $shop_type::shop_type,
    commission_rate = $commission_rate,
    partnership_started_at = CASE WHEN $approved THEN NOW() ELSE NULL END
WHERE id = $shop_id;

-- ê´€ë¦¬ìž ì•¡ì…˜ ë¡œê·¸
INSERT INTO public.admin_actions (
    admin_id, action_type, target_type, target_id, reason
) VALUES (
    $admin_id, 
    CASE WHEN $approved THEN 'shop_approved' ELSE 'shop_rejected' END,
    'shop', $shop_id, $notes
);
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ìŠ¹ì¸ ì²˜ë¦¬**
   - ìŠ¹ì¸ ì‹œ ìƒµ ìƒíƒœë¥¼ 'active'ë¡œ ë³€ê²½
   - íŒŒíŠ¸ë„ˆì‹­ íƒ€ìž… ë° ìˆ˜ìˆ˜ë£Œìœ¨ ì„¤ì •

2. **ì•Œë¦¼ ë°œì†¡**
   - ìƒµ ì˜¤ë„ˆì—ê²Œ ìŠ¹ì¸/ê±°ì ˆ ì•Œë¦¼ ë°œì†¡
   - ìŠ¹ì¸ ì‹œ í™˜ì˜ ë©”ì‹œì§€ ë° ê°€ì´ë“œ ì œê³µ

### **4. ì˜ˆì•½ ê´€ë¦¬ API**

#### **4.1 GET /api/admin/reservations**

##### **ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°**
```
?shopId=uuid&status=confirmed&startDate=2024-03-01&endDate=2024-03-31&page=1&limit=50
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì˜ˆì•½ ëª©ë¡ ì¡°íšŒ (ê´€ë¦¬ìž/ìƒµ ì˜¤ë„ˆë³„ ê¶Œí•œ ì ìš©)
SELECT r.id, r.reservation_date, r.reservation_time, r.status,
       r.total_amount, r.deposit_amount, r.points_used,
       u.name as customer_name, u.phone_number as customer_phone,
       s.name as shop_name, s.id as shop_id,
       array_agg(ss.name) as service_names
FROM public.reservations r
JOIN public.users u ON r.user_id = u.id
JOIN public.shops s ON r.shop_id = s.id
JOIN public.reservation_services rs ON r.id = rs.reservation_id
JOIN public.shop_services ss ON rs.service_id = ss.id
WHERE ($shop_id IS NULL OR r.shop_id = $shop_id)
  AND ($status IS NULL OR r.status = $status::reservation_status)
  AND ($start_date IS NULL OR r.reservation_date >= $start_date)
  AND ($end_date IS NULL OR r.reservation_date <= $end_date)
  AND (
    $admin_role = 'admin' OR 
    (s.owner_id = $admin_id AND $admin_role = 'shop_owner')
  )
GROUP BY r.id, u.id, s.id
ORDER BY r.reservation_datetime DESC
LIMIT $limit OFFSET $offset;
```

#### **4.2 PUT /api/admin/reservations/:reservationId/status**

##### **ìš”ì²­ êµ¬ì¡°**
```json
{
  "status": "confirmed",
  "notes": "ì˜ˆì•½ í™•ì •ë˜ì—ˆìŠµë‹ˆë‹¤"
}
```

##### **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
1. **ìƒíƒœ ë³€ê²½ ê¶Œí•œ í™•ì¸**
   - Super Admin: ëª¨ë“  ì˜ˆì•½ ê´€ë¦¬ ê°€ëŠ¥
   - Shop Owner: ìžì‹ ì˜ ìƒµ ì˜ˆì•½ë§Œ ê´€ë¦¬

2. **ìƒíƒœë³„ ì²˜ë¦¬ ë¡œì§**
   - confirmed: ê³ ê°ì—ê²Œ í™•ì • ì•Œë¦¼
   - completed: í¬ì¸íŠ¸ ì ë¦½ ì²˜ë¦¬
   - cancelled: í™˜ë¶ˆ ì²˜ë¦¬ íŠ¸ë¦¬ê±°

### **5. ê²°ì œ ë° ì •ì‚° API (Super Admin)**

#### **5.1 GET /api/admin/payments/summary**

##### **ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°**
```
?startDate=2024-03-01&endDate=2024-03-31&shopId=uuid
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ê²°ì œ ìš”ì•½ í†µê³„
SELECT 
    DATE_TRUNC('day', p.paid_at) as payment_date,
    COUNT(*) as transaction_count,
    SUM(p.amount) as total_amount,
    SUM(CASE WHEN p.is_deposit THEN p.amount ELSE 0 END) as deposit_amount,
    SUM(CASE WHEN NOT p.is_deposit THEN p.amount ELSE 0 END) as full_payment_amount,
    COUNT(DISTINCT p.user_id) as unique_customers
FROM public.payments p
JOIN public.reservations r ON p.reservation_id = r.id
WHERE p.payment_status = 'fully_paid'
  AND p.paid_at BETWEEN $start_date AND $end_date
  AND ($shop_id IS NULL OR r.shop_id = $shop_id)
GROUP BY DATE_TRUNC('day', p.paid_at)
ORDER BY payment_date DESC;
```

#### **5.2 GET /api/admin/settlements**

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ìƒµë³„ ì •ì‚° ë‚´ì—­
SELECT s.id, s.name, s.commission_rate,
       COUNT(r.id) as completed_reservations,
       SUM(r.total_amount) as gross_revenue,
       SUM(r.total_amount * s.commission_rate / 100) as commission_amount,
       SUM(r.total_amount * (100 - s.commission_rate) / 100) as net_payout
FROM public.shops s
JOIN public.reservations r ON s.id = r.shop_id
WHERE r.status = 'completed'
  AND r.completed_at BETWEEN $start_date AND $end_date
  AND s.shop_type = 'partnered'
GROUP BY s.id
ORDER BY gross_revenue DESC;
```

---

## ðŸ”” ì•Œë¦¼ ì‹œìŠ¤í…œ

### **í‘¸ì‹œ ì•Œë¦¼ ì„œë¹„ìŠ¤**

#### **FCM ì—°ë™ êµ¬í˜„**
```typescript
// services/notification.service.ts
class NotificationService {
  async sendPushNotification(
    userId: string, 
    title: string, 
    message: string,
    data?: any
  ) {
    // FCM í† í° ì¡°íšŒ
    const tokens = await this.getUserFCMTokens(userId);
    
    // FCM ë©”ì‹œì§€ ë°œì†¡
    const fcmMessage = {
      notification: { title, body: message },
      data: data || {},
      tokens: tokens
    };
    
    return await admin.messaging().sendMulticast(fcmMessage);
  }
}
```

#### **ì•Œë¦¼ íŠ¸ë¦¬ê±° ì´ë²¤íŠ¸**
1. **ì˜ˆì•½ ê´€ë ¨ ì•Œë¦¼**
   - ì˜ˆì•½ ìš”ì²­ ì ‘ìˆ˜: ìƒµ ì˜¤ë„ˆì—ê²Œ ì•Œë¦¼
   - ì˜ˆì•½ í™•ì •: ê³ ê°ì—ê²Œ ì•Œë¦¼
   - ì˜ˆì•½ ì·¨ì†Œ: ì–‘ì¸¡ì—ê²Œ ì•Œë¦¼

2. **í¬ì¸íŠ¸ ê´€ë ¨ ì•Œë¦¼**
   - í¬ì¸íŠ¸ ì ë¦½: ì„œë¹„ìŠ¤ ì™„ë£Œ í›„ ê³ ê°ì—ê²Œ
   - í¬ì¸íŠ¸ ë§Œë£Œ ì˜ˆì •: ë§Œë£Œ 7ì¼ ì „ ì•Œë¦¼

3. **ì‹œìŠ¤í…œ ì•Œë¦¼**
   - ìƒˆ ê³µì§€ì‚¬í•­: ì „ì²´ ì‚¬ìš©ìž
   - ë§ˆì¼€íŒ… ì •ë³´: ë™ì˜í•œ ì‚¬ìš©ìžë§Œ

### **ì‹¤ì‹œê°„ ì•Œë¦¼ ì²˜ë¦¬**

#### **ì›¹ì†Œì¼“ ì—°ê²° ê´€ë¦¬**
```typescript
// WebSocketì„ í†µí•œ ì‹¤ì‹œê°„ ì•Œë¦¼
io.on('connection', (socket) => {
  socket.on('join_admin_room', (adminId) => {
    socket.join(`admin_${adminId}`);
  });
  
  // ìƒˆ ì˜ˆì•½ ì•Œë¦¼
  socket.on('new_reservation', (data) => {
    io.to(`admin_${data.shopOwnerId}`).emit('reservation_alert', data);
  });
});
```

---

## ðŸ“Š ë¶„ì„ ë° í†µê³„ API

### **ëŒ€ì‹œë³´ë“œ í†µê³„ API**

#### **GET /api/admin/analytics/dashboard**

##### **ì‘ë‹µ êµ¬ì¡°**
```json
{
  "overview": {
    "totalUsers": 15420,
    "totalShops": 234,
    "totalReservations": 3421,
    "totalRevenue": 125000000
  },
  "growth": {
    "userGrowthRate": 12.5,
    "revenueGrowthRate": 8.3,
    "reservationGrowthRate": 15.2
  },
  "chartData": {
    "dailyRegistrations": [...],
    "monthlyRevenue": [...],
    "categoryDistribution": [...]
  }
}
```

##### **ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©**
```sql
-- ì „ì²´ í”Œëž«í¼ í†µê³„
WITH current_month AS (
  SELECT COUNT(*) as users_this_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW())
),
previous_month AS (
  SELECT COUNT(*) as users_last_month
  FROM public.users 
  WHERE created_at >= date_trunc('month', NOW()) - interval '1 month'
    AND created_at < date_trunc('month', NOW())
)
SELECT 
  (SELECT COUNT(*) FROM public.users WHERE user_status = 'active') as total_users,
  (SELECT COUNT(*) FROM public.shops WHERE shop_status = 'active') as total_shops,
  (SELECT COUNT(*) FROM public.reservations) as total_reservations,
  (SELECT SUM(total_amount) FROM public.reservations WHERE status = 'completed') as total_revenue,
  (cm.users_this_month::float / NULLIF(pm.users_last_month, 0) - 1) * 100 as user_growth_rate
FROM current_month cm, previous_month pm;
```

---

## ðŸ› ï¸ ìœ í‹¸ë¦¬í‹° ë° ë„ìš°ë¯¸ ì„œë¹„ìŠ¤

### **ì´ë©”ì¼ ì„œë¹„ìŠ¤**
```typescript
// services/email.service.ts
class EmailService {
  async sendWelcomeEmail(user: User) {
    // í™˜ì˜ ì´ë©”ì¼ í…œí”Œë¦¿ ë°œì†¡
  }
  
  async sendReservationConfirmation(reservation: Reservation) {
    // ì˜ˆì•½ í™•ì¸ ì´ë©”ì¼ ë°œì†¡
  }
}
```

### **ì´ë¯¸ì§€ ì²˜ë¦¬ ì„œë¹„ìŠ¤**
```typescript
// services/image.service.ts
class ImageService {
  async optimizeAndUpload(file: Buffer, path: string) {
    // ì´ë¯¸ì§€ ì••ì¶• ë° Supabase Storage ì—…ë¡œë“œ
    const optimized = await sharp(file)
      .resize(800, 600, { fit: 'inside' })
      .jpeg({ quality: 80 })
      .toBuffer();
      
    return await supabase.storage
      .from('shop-images')
      .upload(path, optimized);
  }
}
```

### **ê²€ìƒ‰ ì„œë¹„ìŠ¤**
```typescript
// services/search.service.ts
class SearchService {
  async searchShops(query: string, filters: SearchFilters) {
    // ì „ë¬¸ ê²€ìƒ‰ ê¸°ëŠ¥ êµ¬í˜„
    // PostgreSQL Full-Text Search í™œìš©
  }
}
```

---

## ðŸ”§ ì—ëŸ¬ ì²˜ë¦¬ ë° ë¡œê¹…

### **í‘œì¤€í™”ëœ ì—ëŸ¬ ì‘ë‹µ í˜•ì‹**
```typescript
// í‘œì¤€ ì—ëŸ¬ ì‘ë‹µ êµ¬ì¡°
interface ErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Array<{
      field: string;
      message: string;
    }>;
    timestamp: string;
    requestId: string;
  };
}

// ì—ëŸ¬ ì½”ë“œ ì •ì˜
const ERROR_CODES = {
  // ì¸ì¦ ê´€ë ¨ (1000-1999)
  UNAUTHORIZED: "AUTH_1001",
  TOKEN_EXPIRED: "AUTH_1002",
  INVALID_CREDENTIALS: "AUTH_1003",
  INSUFFICIENT_PERMISSIONS: "AUTH_1004",
  SESSION_TIMEOUT: "AUTH_1005",
  
  // ê²€ì¦ ê´€ë ¨ (2000-2999)
  VALIDATION_ERROR: "VALID_2001",
  MISSING_REQUIRED_FIELD: "VALID_2002",
  INVALID_FORMAT: "VALID_2003",
  INVALID_PHONE_FORMAT: "VALID_2004",
  INVALID_BUSINESS_LICENSE: "VALID_2005",
  
  // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (3000-3999)
  RESOURCE_NOT_FOUND: "BUSINESS_3001",
  INVALID_STATE_TRANSITION: "BUSINESS_3002",
  INSUFFICIENT_POINTS: "BUSINESS_3003",
  SLOT_NOT_AVAILABLE: "BUSINESS_3004",
  CONCURRENT_BOOKING: "BUSINESS_3005",
  POINT_EXPIRED: "BUSINESS_3006",
  
  // ê²°ì œ ê´€ë ¨ (4000-4999)
  PAYMENT_FAILED: "PAYMENT_4001",
  REFUND_FAILED: "PAYMENT_4002",
  INSUFFICIENT_FUNDS: "PAYMENT_4003",
  PARTIAL_REFUND_NOT_ALLOWED: "PAYMENT_4004",
  
  // ì‹œìŠ¤í…œ ê´€ë ¨ (5000-5999)
  INTERNAL_SERVER_ERROR: "SYSTEM_5001",
  DATABASE_ERROR: "SYSTEM_5002",
  EXTERNAL_SERVICE_ERROR: "SYSTEM_5003"
};

// í†µí•© ì—ëŸ¬ ì²˜ë¦¬
export const errorHandler = (error: Error, req: Request, res: Response, next: NextFunction) => {
  const requestId = req.headers['x-request-id'] as string || generateRequestId();
  
  logger.error({
    message: error.message,
    stack: error.stack,
    path: req.path,
    method: req.method,
    user: req.user?.id,
    requestId
  });
  
  if (error instanceof ValidationError) {
    return res.status(400).json({
      success: false,
      error: {
        code: ERROR_CODES.VALIDATION_ERROR,
        message: "ìž…ë ¥ ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤",
        details: error.details,
        timestamp: new Date().toISOString(),
        requestId
      }
    });
  }
  
  if (error instanceof AuthenticationError) {
    return res.status(401).json({
      success: false,
      error: {
        code: ERROR_CODES.UNAUTHORIZED,
        message: "ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤",
        timestamp: new Date().toISOString(),
        requestId
      }
    });
  }
  
  // ê¸°ë³¸ ì—ëŸ¬ ì‘ë‹µ
  return res.status(500).json({
    success: false,
    error: {
      code: ERROR_CODES.INTERNAL_SERVER_ERROR,
      message: "ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
      timestamp: new Date().toISOString(),
      requestId
    }
  });
};
```

### **êµ¬ì¡°í™”ëœ ë¡œê¹…**
```typescript
// utils/logger.ts
import winston from 'winston';

export const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});
```

### **ë°ì´í„° ê²€ì¦ ê·œì¹™**
```typescript
// validators/common.validator.ts
import Joi from 'joi';

// í•œêµ­ ì „í™”ë²ˆí˜¸ ê²€ì¦
export const phoneSchema = Joi.string()
  .pattern(/^01[0-9]-[0-9]{3,4}-[0-9]{4}$/)
  .message('ì˜¬ë°”ë¥¸ í•œêµ­ ì „í™”ë²ˆí˜¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤ (ì˜ˆ: 010-1234-5678)');

// ì‚¬ì—…ìžë“±ë¡ë²ˆí˜¸ ê²€ì¦
export const businessLicenseSchema = Joi.string()
  .pattern(/^[0-9]{3}-[0-9]{2}-[0-9]{5}$/)
  .message('ì˜¬ë°”ë¥¸ ì‚¬ì—…ìžë“±ë¡ë²ˆí˜¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤ (ì˜ˆ: 123-45-67890)');

// í•œêµ­ ì£¼ì†Œ ê²€ì¦
export const addressSchema = Joi.string()
  .min(10)
  .max(200)
  .pattern(/^[ê°€-íž£\s]+ì‹œ\s+[ê°€-íž£\s]+êµ¬\s+[ê°€-íž£\s]+ë™/)
  .message('ì˜¬ë°”ë¥¸ í•œêµ­ ì£¼ì†Œ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤');

// ì´ë¯¸ì§€ ì—…ë¡œë“œ ê²€ì¦
export const imageSchema = Joi.object({
  fieldname: Joi.string().valid('image').required(),
  mimetype: Joi.string().valid('image/jpeg', 'image/png', 'image/webp').required(),
  size: Joi.number().max(5 * 1024 * 1024).required(), // 5MB ì œí•œ
  buffer: Joi.binary().required()
});

// í¬ì¸íŠ¸ ê¸ˆì•¡ ê²€ì¦
export const pointAmountSchema = Joi.number()
  .integer()
  .min(1)
  .max(1000000) // ìµœëŒ€ 100ë§Œ í¬ì¸íŠ¸
  .required();
```

### **í¬ì¸íŠ¸ ì‹œìŠ¤í…œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
```typescript
// services/point.service.ts
class PointService {
  // í¬ì¸íŠ¸ ë§Œë£Œ ì²˜ë¦¬ (ë§¤ì¼ ìžì • ì‹¤í–‰)
  async processPointExpiration() {
    const expiredPoints = await supabase
      .from('point_transactions')
      .select('*')
      .eq('status', 'available')
      .lt('expires_at', new Date().toISOString());
    
    for (const point of expiredPoints.data || []) {
      await supabase
        .from('point_transactions')
        .update({ 
          status: 'expired',
          updated_at: new Date().toISOString()
        })
        .eq('id', point.id);
    }
  }
  
  // 7ì¼ í›„ ì‚¬ìš© ê°€ëŠ¥ ìƒíƒœë¡œ ë³€ê²½ (ë§¤ì¼ ìžì • ì‹¤í–‰)
  async processPendingToAvailable() {
    const pendingPoints = await supabase
      .from('point_transactions')
      .select('*')
      .eq('status', 'pending')
      .lte('available_from', new Date().toISOString());
    
    for (const point of pendingPoints.data || []) {
      await supabase
        .from('point_transactions')
        .update({ 
          status: 'available',
          updated_at: new Date().toISOString()
        })
        .eq('id', point.id);
    }
  }
  
  // ì¸í”Œë£¨ì–¸ì„œ ë³´ë„ˆìŠ¤ ê³„ì‚° (2ë°° ì ë¦½)
  async calculateInfluencerBonus(userId: string, baseAmount: number) {
    const user = await supabase
      .from('users')
      .select('is_influencer')
      .eq('id', userId)
      .single();
    
    if (user.data?.is_influencer) {
      return baseAmount * 2; // 2ë°° ë³´ë„ˆìŠ¤
    }
    
    return baseAmount;
  }
  
  // ê´€ë¦¬ìž í¬ì¸íŠ¸ ì¡°ì •
  async adjustPointsByAdmin(userId: string, amount: number, reason: string, adminId: string) {
    const transaction = await supabase
      .from('point_transactions')
      .insert({
        user_id: userId,
        transaction_type: 'adjusted',
        amount: amount,
        description: `ê´€ë¦¬ìž ì¡°ì •: ${reason}`,
        status: 'available',
        metadata: { adjusted_by: adminId }
      });
    
    // ê´€ë¦¬ìž ì•¡ì…˜ ë¡œê·¸ ê¸°ë¡
    await supabase
      .from('admin_actions')
      .insert({
        admin_id: adminId,
        action_type: 'points_adjusted',
        target_type: 'user',
        target_id: userId,
        reason: reason,
        metadata: { amount, previous_balance: await this.getUserBalance(userId) }
      });
    
    return transaction;
  }
}
```

### **ì˜ˆì•½ ì‹œìŠ¤í…œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
```typescript
// services/reservation.service.ts
class ReservationService {
  // ë™ì‹œ ì˜ˆì•½ ë°©ì§€
  async checkConcurrentBooking(shopId: string, date: string, time: string, duration: number) {
    const startTime = new Date(`${date} ${time}`);
    const endTime = new Date(startTime.getTime() + duration * 60000);
    
    const conflictingReservations = await supabase
      .from('reservations')
      .select('*')
      .eq('shop_id', shopId)
      .eq('reservation_date', date)
      .in('status', ['requested', 'confirmed'])
      .overlaps('reservation_datetime', startTime.toISOString(), endTime.toISOString());
    
    return conflictingReservations.data?.length === 0;
  }
  
  // ë…¸ì‡¼ ê°ì§€ (ì˜ˆì•½ ì‹œê°„ 30ë¶„ í›„ ìžë™ ì²˜ë¦¬)
  async detectNoShow() {
    const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
    
    const noShowReservations = await supabase
      .from('reservations')
      .select('*')
      .eq('status', 'confirmed')
      .lt('reservation_datetime', thirtyMinutesAgo.toISOString());
    
    for (const reservation of noShowReservations.data || []) {
      await supabase
        .from('reservations')
        .update({ 
          status: 'no_show',
          no_show_reason: 'ì˜ˆì•½ ì‹œê°„ 30ë¶„ ê²½ê³¼ë¡œ ë…¸ì‡¼ ì²˜ë¦¬',
          updated_at: new Date().toISOString()
        })
        .eq('id', reservation.id);
    }
  }
  
  // ì˜ˆì•½ ìž¬ìŠ¤ì¼€ì¤„
  async rescheduleReservation(reservationId: string, newDate: string, newTime: string) {
    // ê¸°ì¡´ ì˜ˆì•½ ì·¨ì†Œ
    await this.cancelReservation(reservationId, 'rescheduled');
    
    // ìƒˆ ì˜ˆì•½ ìƒì„±
    const originalReservation = await supabase
      .from('reservations')
      .select('*')
      .eq('id', reservationId)
      .single();
    
    return await supabase
      .from('reservations')
      .insert({
        user_id: originalReservation.data.user_id,
        shop_id: originalReservation.data.shop_id,
        reservation_date: newDate,
        reservation_time: newTime,
        status: 'requested',
        total_amount: originalReservation.data.total_amount,
        deposit_amount: originalReservation.data.deposit_amount,
        special_requests: originalReservation.data.special_requests
      });
  }
}
```

### **ê²°ì œ ì‹œìŠ¤í…œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
```typescript
// services/payment.service.ts
class PaymentService {
  // ë¶€ë¶„ í™˜ë¶ˆ ì²˜ë¦¬
  async processPartialRefund(paymentId: string, refundAmount: number, reason: string) {
    const payment = await supabase
      .from('payments')
      .select('*')
      .eq('id', paymentId)
      .single();
    
    if (refundAmount > payment.data.amount) {
      throw new Error('í™˜ë¶ˆ ê¸ˆì•¡ì´ ê²°ì œ ê¸ˆì•¡ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }
    
    const newStatus = refundAmount === payment.data.amount ? 'refunded' : 'partially_refunded';
    
    return await supabase
      .from('payments')
      .update({
        payment_status: newStatus,
        refund_amount: refundAmount,
        refunded_at: new Date().toISOString(),
        metadata: { ...payment.data.metadata, refund_reason: reason }
      })
      .eq('id', paymentId);
  }
  
  // ìˆ˜ìˆ˜ë£Œ ê³„ì‚° (ì‹¤ì‹œê°„)
  async calculateCommission(shopId: string, amount: number) {
    const shop = await supabase
      .from('shops')
      .select('commission_rate, shop_type')
      .eq('id', shopId)
      .single();
    
    if (shop.data.shop_type === 'partnered') {
      return (amount * shop.data.commission_rate) / 100;
    }
    
    return 0; // ë¹„ìž…ì ìƒµì€ ìˆ˜ìˆ˜ë£Œ ì—†ìŒ
  }
  
  // ë¶„í•  ê²°ì œ ì²˜ë¦¬ (ì˜ˆì•½ê¸ˆ + ìž”ê¸ˆ)
  async processSplitPayment(reservationId: string, depositAmount: number, totalAmount: number) {
    // ì˜ˆì•½ê¸ˆ ê²°ì œ
    const depositPayment = await supabase
      .from('payments')
      .insert({
        reservation_id: reservationId,
        payment_method: 'toss_payments',
        payment_status: 'deposit_paid',
        amount: depositAmount,
        is_deposit: true
      });
    
    // ìž”ê¸ˆì€ ë‚˜ì¤‘ì— ê²°ì œ
    const remainingAmount = totalAmount - depositAmount;
    
    return {
      deposit_payment: depositPayment.data,
      remaining_amount: remainingAmount
    };
  }
}
```

---

## ðŸš€ ë°°í¬ ë° ìš´ì˜

### **í™˜ê²½ ì„¤ì •**
```typescript
// config/database.ts
export const dbConfig = {
  development: {
    url: process.env.SUPABASE_URL_DEV,
    key: process.env.SUPABASE_ANON_KEY_DEV
  },
  production: {
    url: process.env.SUPABASE_URL_PROD,
    key: process.env.SUPABASE_ANON_KEY_PROD
  }
};
```

### **ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (WebSocket)**
```typescript
// services/websocket.service.ts
import { Server } from 'socket.io';

class WebSocketService {
  private io: Server;
  
  constructor(server: any) {
    this.io = new Server(server, {
      cors: {
        origin: process.env.FRONTEND_URL,
        methods: ["GET", "POST"]
      }
    });
    
    this.setupEventHandlers();
  }
  
  private setupEventHandlers() {
    this.io.on('connection', (socket) => {
      // ê´€ë¦¬ìž ì¸ì¦
      socket.on('admin_auth', async (token) => {
        try {
          const admin = await this.verifyAdminToken(token);
          socket.join(`admin_${admin.id}`);
          socket.emit('auth_success', { adminId: admin.id });
        } catch (error) {
          socket.emit('auth_error', { message: 'ì¸ì¦ ì‹¤íŒ¨' });
        }
      });
      
      // ìƒµ ì˜¤ë„ˆ ì¸ì¦
      socket.on('shop_owner_auth', async (token) => {
        try {
          const shopOwner = await this.verifyShopOwnerToken(token);
          socket.join(`shop_${shopOwner.shop_id}`);
          socket.emit('auth_success', { shopId: shopOwner.shop_id });
        } catch (error) {
          socket.emit('auth_error', { message: 'ì¸ì¦ ì‹¤íŒ¨' });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('Client disconnected');
      });
    });
  }
  
  // ì‹¤ì‹œê°„ ì•Œë¦¼ ë°œì†¡
  public sendAdminNotification(adminId: string, notification: any) {
    this.io.to(`admin_${adminId}`).emit('notification', notification);
  }
  
  // ìƒµ ì˜ˆì•½ ì—…ë°ì´íŠ¸ ì•Œë¦¼
  public sendShopReservationUpdate(shopId: string, reservation: any) {
    this.io.to(`shop_${shopId}`).emit('reservation_update', reservation);
  }
  
  // ê¸´ê¸‰ ì•Œë¦¼ (ëª¨ë“  ê´€ë¦¬ìž)
  public sendUrgentNotification(notification: any) {
    this.io.to('admin_*').emit('urgent_notification', notification);
  }
}
```

### **ìºì‹± ì „ëžµ**
```typescript
// services/cache.service.ts
import Redis from 'ioredis';

class CacheService {
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
  }
  
  // ìƒµ ì •ë³´ ìºì‹± (1ì‹œê°„)
  async cacheShopInfo(shopId: string, shopData: any) {
    await this.redis.setex(`shop:${shopId}`, 3600, JSON.stringify(shopData));
  }
  
  // ì‚¬ìš©ìž í¬ì¸íŠ¸ ìºì‹± (5ë¶„)
  async cacheUserPoints(userId: string, pointsData: any) {
    await this.redis.setex(`points:${userId}`, 300, JSON.stringify(pointsData));
  }
  
  // ì˜ˆì•½ í˜„í™© ìºì‹± (1ë¶„)
  async cacheReservationStatus(shopId: string, date: string, status: any) {
    await this.redis.setex(`reservations:${shopId}:${date}`, 60, JSON.stringify(status));
  }
  
  // ìºì‹œ ë¬´íš¨í™”
  async invalidateCache(pattern: string) {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

### **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**
- **APM ë„êµ¬**: New Relic ë˜ëŠ” DataDog ì—°ë™
- **í—¬ìŠ¤ì²´í¬**: `/health` ì—”ë“œí¬ì¸íŠ¸ë¡œ ì„œë²„ ìƒíƒœ í™•ì¸
- **ë©”íŠ¸ë¦­ ìˆ˜ì§‘**: Prometheus + Grafana ëŒ€ì‹œë³´ë“œ
- **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**: WebSocket ì—°ê²° ìˆ˜, API ì‘ë‹µ ì‹œê°„, ì—ëŸ¬ìœ¨

### **ê¶Œí•œ ë§¤íŠ¸ë¦­ìŠ¤ (Permission Matrix)**
```typescript
// types/permissions.ts
export const PERMISSIONS = {
  // ì‚¬ìš©ìž ê´€ë¦¬
  USERS_READ: 'users:read',
  USERS_WRITE: 'users:write',
  USERS_DELETE: 'users:delete',
  USERS_SUSPEND: 'users:suspend',
  
  // ìƒµ ê´€ë¦¬
  SHOPS_READ: 'shops:read',
  SHOPS_WRITE: 'shops:write',
  SHOPS_DELETE: 'shops:delete',
  SHOPS_VERIFY: 'shops:verify',
  
  // ì˜ˆì•½ ê´€ë¦¬
  RESERVATIONS_READ: 'reservations:read',
  RESERVATIONS_WRITE: 'reservations:write',
  RESERVATIONS_CANCEL: 'reservations:cancel',
  
  // ê²°ì œ ê´€ë¦¬
  PAYMENTS_READ: 'payments:read',
  PAYMENTS_REFUND: 'payments:refund',
  PAYMENTS_PARTIAL_REFUND: 'payments:partial_refund',
  
  // í¬ì¸íŠ¸ ê´€ë¦¬
  POINTS_READ: 'points:read',
  POINTS_ADJUST: 'points:adjust',
  
  // ì½˜í…ì¸  ê´€ë¦¬
  CONTENT_READ: 'content:read',
  CONTENT_WRITE: 'content:write',
  CONTENT_DELETE: 'content:delete',
  
  // ì‹œìŠ¤í…œ ì„¤ì •
  SYSTEM_READ: 'system:read',
  SYSTEM_WRITE: 'system:write',
  SYSTEM_ADMIN: 'system:admin'
};

// ì—­í• ë³„ ê¶Œí•œ ì •ì˜
export const ROLE_PERMISSIONS = {
  // Super Admin: ëª¨ë“  ê¶Œí•œ
  super_admin: Object.values(PERMISSIONS),
  
  // Shop Admin: ìžì‹ ì˜ ìƒµ ê´€ë ¨ ê¶Œí•œë§Œ
  shop_admin: [
    PERMISSIONS.USERS_READ,
    PERMISSIONS.SHOPS_READ,
    PERMISSIONS.RESERVATIONS_READ,
    PERMISSIONS.RESERVATIONS_WRITE,
    PERMISSIONS.RESERVATIONS_CANCEL,
    PERMISSIONS.PAYMENTS_READ,
    PERMISSIONS.CONTENT_READ
  ],
  
  // ì¼ë°˜ ì‚¬ìš©ìž: ì½ê¸° ê¶Œí•œë§Œ
  user: [
    PERMISSIONS.USERS_READ,
    PERMISSIONS.SHOPS_READ,
    PERMISSIONS.RESERVATIONS_READ,
    PERMISSIONS.PAYMENTS_READ,
    PERMISSIONS.POINTS_READ,
    PERMISSIONS.CONTENT_READ
  ]
};

// ê¶Œí•œ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´
export const checkPermission = (requiredPermission: string) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user?.user_role;
    const userPermissions = ROLE_PERMISSIONS[userRole] || [];
    
    if (!userPermissions.includes(requiredPermission)) {
      return res.status(403).json({
        success: false,
        error: {
          code: ERROR_CODES.INSUFFICIENT_PERMISSIONS,
          message: "í•´ë‹¹ ìž‘ì—…ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤",
          timestamp: new Date().toISOString(),
          requestId: req.headers['x-request-id'] as string
        }
      });
    }
    
    next();
  };
};
```

### **í…ŒìŠ¤íŒ… ì „ëžµ (Testing Strategy)**
```typescript
// tests/integration/api.test.ts
describe('API Integration Tests', () => {
  // ì¸ì¦ í…ŒìŠ¤íŠ¸
  describe('Authentication', () => {
    test('should authenticate valid user', async () => {
      const response = await request(app)
        .post('/api/auth/social-login')
        .send({
          provider: 'kakao',
          token: 'valid_token',
          deviceInfo: { platform: 'ios', version: '1.0.0' }
        });
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.jwt_token).toBeDefined();
    });
    
    test('should reject invalid token', async () => {
      const response = await request(app)
        .post('/api/auth/social-login')
        .send({
          provider: 'kakao',
          token: 'invalid_token',
          deviceInfo: { platform: 'ios', version: '1.0.0' }
        });
      
      expect(response.status).toBe(401);
      expect(response.body.error.code).toBe('AUTH_1003');
    });
  });
  
  // ì˜ˆì•½ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
  describe('Reservation System', () => {
    test('should prevent concurrent bookings', async () => {
      // ë™ì‹œ ì˜ˆì•½ ì‹œë„ í…ŒìŠ¤íŠ¸
      const promises = Array(3).fill(null).map(() =>
        request(app)
          .post('/api/reservations')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            shop_id: 'test_shop_id',
            reservation_date: '2024-03-20',
            reservation_time: '14:00',
            services: [{ service_id: 'test_service', quantity: 1 }]
          })
      );
      
      const results = await Promise.all(promises);
      const successful = results.filter(r => r.status === 200);
      
      expect(successful.length).toBe(1); // í•˜ë‚˜ë§Œ ì„±ê³µí•´ì•¼ í•¨
    });
  });
  
  // í¬ì¸íŠ¸ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
  describe('Point System', () => {
    test('should apply influencer bonus correctly', async () => {
      const response = await request(app)
        .post('/api/points/earn')
        .set('Authorization', `Bearer ${influencerToken}`)
        .send({
          reservation_id: 'test_reservation',
          amount: 1000
        });
      
      expect(response.body.points_earned).toBe(2000); // 2ë°° ë³´ë„ˆìŠ¤
    });
  });
});

// E2E í…ŒìŠ¤íŠ¸
describe('End-to-End Tests', () => {
  test('complete reservation flow', async () => {
    // 1. ì‚¬ìš©ìž ë¡œê·¸ì¸
    const loginResponse = await request(app)
      .post('/api/auth/social-login')
      .send(loginData);
    
    const token = loginResponse.body.jwt_token;
    
    // 2. ìƒµ ê²€ìƒ‰
    const searchResponse = await request(app)
      .get('/api/shops/nearby')
      .set('Authorization', `Bearer ${token}`)
      .query({ latitude: 37.5665, longitude: 126.9780 });
    
    const shopId = searchResponse.body.shops[0].id;
    
    // 3. ì˜ˆì•½ ìƒì„±
    const reservationResponse = await request(app)
      .post('/api/reservations')
      .set('Authorization', `Bearer ${token}`)
      .send({
        shop_id: shopId,
        reservation_date: '2024-03-20',
        reservation_time: '14:00',
        services: [{ service_id: 'test_service', quantity: 1 }]
      });
    
    expect(reservationResponse.status).toBe(200);
    
    // 4. ê²°ì œ ì²˜ë¦¬
    const paymentResponse = await request(app)
      .post('/api/payments/toss/prepare')
      .set('Authorization', `Bearer ${token}`)
      .send({
        reservation_id: reservationResponse.body.reservation.id,
        amount: 45000
      });
    
    expect(paymentResponse.status).toBe(200);
  });
});
```

### **ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì„¤ì • (Monitoring Setup)**
```typescript
// monitoring/health-check.ts
export const healthCheck = {
  // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ
  database: async () => {
    try {
      const { data, error } = await supabase
        .from('users')
        .select('count')
        .limit(1);
      
      return {
        status: error ? 'error' : 'healthy',
        response_time: Date.now(),
        error: error?.message
      };
    } catch (error) {
      return {
        status: 'error',
        response_time: Date.now(),
        error: error.message
      };
    }
  },
  
  // ì™¸ë¶€ API ìƒíƒœ (í† ìŠ¤íŽ˜ì´ë¨¼ì¸ )
  external_apis: async () => {
    try {
      const response = await fetch('https://api.tosspayments.com/v1/health');
      return {
        status: response.ok ? 'healthy' : 'error',
        response_time: Date.now(),
        error: response.ok ? null : 'TossPayments API unavailable'
      };
    } catch (error) {
      return {
        status: 'error',
        response_time: Date.now(),
        error: error.message
      };
    }
  },
  
  // ë©”ëª¨ë¦¬ ë° CPU ì‚¬ìš©ëŸ‰
  system_resources: () => {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();
    
    return {
      memory: {
        rss: memUsage.rss,
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        external: memUsage.external
      },
      cpu: {
        user: cpuUsage.user,
        system: cpuUsage.system
      }
    };
  }
};

// ì•Œë¦¼ ì„¤ì •
export const alerting = {
  // ì—ëŸ¬ìœ¨ ì•Œë¦¼
  errorRate: {
    threshold: 0.05, // 5% ì´ìƒ ì—ëŸ¬ìœ¨
    window: 300000, // 5ë¶„ ìœˆë„ìš°
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL,
      email: process.env.ALERT_EMAIL
    }
  },
  
  // ì‘ë‹µ ì‹œê°„ ì•Œë¦¼
  responseTime: {
    threshold: 2000, // 2ì´ˆ ì´ìƒ
    window: 60000, // 1ë¶„ ìœˆë„ìš°
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL
    }
  },
  
  // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨
  databaseConnection: {
    threshold: 3, // 3íšŒ ì—°ì† ì‹¤íŒ¨
    window: 60000, // 1ë¶„ ìœˆë„ìš°
    notification: {
      slack: process.env.SLACK_WEBHOOK_URL,
      email: process.env.ALERT_EMAIL,
      sms: process.env.ALERT_SMS
    }
  }
};

// ë©”íŠ¸ë¦­ ìˆ˜ì§‘
export const metrics = {
  // API í˜¸ì¶œ ìˆ˜
  apiCalls: new Map(),
  
  // ì‘ë‹µ ì‹œê°„
  responseTimes: new Map(),
  
  // ì—ëŸ¬ ìˆ˜
  errorCount: new Map(),
  
  // í™œì„± ì‚¬ìš©ìž ìˆ˜
  activeUsers: new Set(),
  
  // ì‹¤ì‹œê°„ ì˜ˆì•½ ìˆ˜
  activeReservations: 0
};
```

### **ë³´ì•ˆ ê°•í™”**
- **HTTPS ê°•ì œ**: SSL ì¸ì¦ì„œ ì ìš©
- **API í‚¤ ê´€ë¦¬**: AWS Secrets Manager ë˜ëŠ” í™˜ê²½ë³€ìˆ˜
- **ë°ì´í„°ë² ì´ìŠ¤ ë³´ì•ˆ**: RLS ì •ì±… + VPC ë„¤íŠ¸ì›Œí¬ ê²©ë¦¬

---

ì´ ì„¤ê³„ì„œëŠ” ì—ë·°ë¦¬ëµ í”ŒëŸ¬í„° ì•±ê³¼ ì›¹ ê´€ë¦¬ìž ì‹œìŠ¤í…œì„ ì§€ì›í•˜ëŠ” Node.js ë°±ì—”ë“œì˜ ëª¨ë“  API ì—”ë“œí¬ì¸íŠ¸, ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§, ë°ì´í„°ë² ì´ìŠ¤ ìƒí˜¸ìž‘ìš©ì„ ìƒì„¸ížˆ ì„¤ëª…í•©ë‹ˆë‹¤. ê°œë°œíŒ€ê³¼ì˜ ê¸°ìˆ  ë…¼ì˜ ë° êµ¬í˜„ ê°€ì´ë“œë¡œ í™œìš©í•  ìˆ˜ ìžˆë„ë¡ êµ¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. 